{"version":3,"sources":["angular-svg-nodes-controller.js"],"names":[],"mappings":"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","file":"angular-svg-nodes-controller.js","sourcesContent":["import {\n    BLOCK_TOP_LEFT,\n    BLOCK_TOP,\n    BLOCK_CENTER,\n    BLOCK_BOTTOM,\n    ACTION_ADD,\n    ACTION_REMOVE,\n    ACTION_UPDATE,\n    INITIAL_GRID_COLS,\n    INITIAL_GRID_ROWS,\n    BLOCK_WIDTH,\n    BLOCK_HEIGHT,\n    COL_SPACING,\n    ROW_SPACING,\n    LABEL_SPACING,\n    DISABLE_CONTROL_NODES,\n    MAX_VIEWPORT_WIDTH_INCREASE,\n    MAX_VIEWPORT_HEIGHT_INCREASE\n} from \"./angular-svg-nodes-settings\";\n\nimport * as Utils from './angular-svg-nodes-utils'; \n\nexport default class AngularSvgNodesController {\n\n    constructor($s) {\n\n        this.$s = $s;\n\n        //-----------------------------\n        // directives vars\n        //-----------------------------\n        //\n        // this.rows\n        // this.api\n        //\n        //-----------------------------\n\n        if (_.isUndefined(this.api)) {\n            this.api = {};\n        }\n\n        //-----------------------------\n        // control\n        //-----------------------------\n\n        var initialized = false;\n\n        // an array of block coords that will be set as connected on teh line\n        this.blocks_waiting_for_connection = [];\n\n        // parent coordinates (for reference)\n        this.parent_coords = [];\n\n        // view coordinates (for reference)\n        this.coords = [];\n\n        // view element data\n        this.blocks = [];\n\n        // array for bg grid\n        this.bg_col_grid = [];\n        this.bg_col_grid_hover_index = null;\n\n        // grid dimmensions\n        this.block_width = BLOCK_WIDTH;\n        this.block_height = BLOCK_HEIGHT;\n        this.col_spacing = COL_SPACING;\n        this.row_spacing = ROW_SPACING;\n        this.grid_col_count = INITIAL_GRID_COLS;\n        this.grid_row_count = INITIAL_GRID_ROWS;\n        this.label_width = BLOCK_WIDTH - (LABEL_SPACING * 2);\n        this.label_height = BLOCK_HEIGHT - (LABEL_SPACING * 2);\n\n        // viewport style & bounds\n        this.wrapper_style = \"\";\n        this.viewport_style = \"\";\n        this.viewport_width = 0;\n        this.viewport_height = 0;\n        this.viewport_viewbox = \"\";\n\n        // node selections\n        this.selection = [];\n        this.source_exit_side = null;\n\n        // active node\n        this.selected_node = [];\n\n        ////////////////////////////////////////////////\n        //\n        // watchers\n        //\n        ////////////////////////////////////////////////\n\n        this.$s.$watch('AngularSvgNodes.selection', (newValue, oldValue) => {\n\n            if (!_.isUndefined(newValue)) {\n\n                // two selected & target is child of source\n                if (newValue.length === 2 && newValue[1][1] > newValue[0][1]) {\n\n                    // new target selection\n                    if (newValue.length > oldValue.length) {\n\n                        // add line\n                        this.addLine(this.selection[0], this.selection[1]);\n                    }\n\n                    // updated target selection\n                    else {\n\n                        // update line\n                        this.updateLineTarget(this.selection[0], this.selection[1]);\n                    }\n                }\n            }\n        }, true);\n\n        this.$s.$watch('AngularSvgNodes.rows', (newValue) => {\n\n            if (_.isUndefined(newValue)) {\n                return;\n            }\n\n            // init\n            if (!initialized) {\n                this.init(newValue, 'columns');\n                initialized = true;\n                return true;\n            }\n\n            // update\n            this.update(newValue, 'columns');\n\n        }, true);\n\n        ////////////////////////////////////////////////\n        //\n        // api\n        //\n        ////////////////////////////////////////////////\n\n        /**\n         * addLine\n         *\n         * @param {Array}    source_coords\n         * @param {Array}    target_coords\n         * @param {Boolean}  connected\n         */\n\n        this.api.addLine = (source_coords, target_coords, connected) => {\n\n            // style block\n            this.setNodeClass(source_coords[0], source_coords[1], 'connected', true);\n\n            // set target as waiting for connection\n            this.blocks_waiting_for_connection.push(target_coords);\n\n            // add line\n            this.addLine(source_coords, target_coords, connected);\n        };\n\n        /**\n         * insertBlock\n         *\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         * @param {Object}     data\n         */\n\n        this.api.insertBlock = (col_index, row_index, data) => {\n            this.insertBlock(col_index, row_index, data);\n        };\n\n        /**\n         * removeBlock\n         *\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.api.removeBlock = (col_index, row_index) => {\n            this.removeBlock(col_index, row_index);\n        };\n\n        /**\n         * highlightBlock\n         *\n         * @param {Boolean}    value\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.api.highlightBlock = (value, col_index, row_index) => {\n\n            // style block\n            this.setNodeClass(col_index, row_index, 'highlight', value);\n        };\n\n        /**\n         * selectBlock\n         *\n         * @param {Boolean}    value\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.api.selectBlock = (value, col_index, row_index) => {\n\n            if (!_.isUndefined(col_index) && !_.isUndefined(col_index) && value) {\n                this.selected_node = [col_index, row_index];\n                return true;\n            }\n\n            this.selected_node = null;\n        };\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // handlers\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // general\n    //-----------------------------\n\n    /**\n     * onNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeSelect(col_index, row_index) {\n\n        // external handler\n        if (!_.isUndefined(this.onNodeMouseDown)) {\n            this.onNodeMouseDown(this.getExternalNodeEventHandlerData(col_index, row_index));\n        }\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            if (!DISABLE_CONTROL_NODES) {\n                this.onControlNodeSelect(col_index, row_index);\n            }\n            return true;\n        }\n\n        // if block\n        this.onBlockNodeSelect(col_index, row_index);\n    }\n\n    /**\n     * onNodeDeselect\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeDeselect(col_index, row_index) {\n\n        // external handler\n        if (!_.isUndefined(this.onNodeMouseUp)) {\n            this.onNodeMouseUp(this.getExternalNodeEventHandlerData(col_index, row_index));\n        }\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            return false;\n        }\n\n        // if block\n        this.onBlockNodeDeselect(col_index, row_index);\n    }\n\n    /**\n     * onNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeMouseOver(col_index, row_index) {\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            this.onControlNodeMouseOver(col_index, row_index);\n            return true;\n        }\n\n        // if block\n        this.onBlockNodeMouseOver(col_index, row_index);\n    }\n\n    /**\n     * onNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeMouseOut(col_index, row_index, exit_side) {\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            this.onControlNodeMouseOut(col_index, row_index);\n            return true;\n        }\n\n        // if block\n        this.onBlockNodeMouseOut(col_index, row_index, exit_side);\n    }\n\n    //-------------------------------------------------\n    // control node handlers\n    //-------------------------------------------------\n\n    /**\n     * onControlNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onControlNodeSelect(col_index, row_index) {\n\n        this.addBlock(col_index, row_index, \"NEW\", []);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onControlNodeMouseOver(col_index, row_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(col_index, row_index, 'control_hover', true);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onControlNodeMouseOut(col_index, row_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(col_index, row_index, 'control_hover', false);\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // block node handlers\n    //-------------------------------------------------\n\n    /**\n     * onBlockNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onBlockNodeSelect(col_index, row_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        this.setNodeClass(col_index, row_index, 'source_hover', false);\n        this.setNodeClass(col_index, row_index, 'source', true);\n        this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', false);\n        this.setPotentialNodeClasses(col_index, row_index, 'potential_target', true);\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // set selection\n        this.selection = [[col_index, row_index]];\n        this.selected_node = [col_index, row_index];\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBlockNodeDeselect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onBlockNodeDeselect(col_index, row_index) {\n\n        // reset last exit side\n        this.source_exit_side = null;\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if one selection\n        if (this.selection.length === 1) {\n\n            // if deselecting on current source\n            if (_.isEqual(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'source', false);\n                this.setNodeClass(col_index, row_index, 'source_hover', true);\n                this.setPotentialNodeClasses(col_index, row_index, 'potential_target', false);\n                this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', true);\n            }\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if deselecting on current target (& is potential ?)\n            if (_.isEqual(this.selection[1], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'target', false);\n\n                // if  block has no parent connections\n                if (!this.doesNodeHaveConnectedParents(col_index, row_index)) {\n                    this.setPotentialNodeClasses(col_index, row_index, 'potential_target', false);\n                }\n\n                // check active\n                this.checkActive();\n            }\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // if deselecting on current target & is potential\n            if (_.isEqual(this.selection[1], [col_index, row_index]) && this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                var is_target_parent = this.selection[0][1] > row_index;\n\n                // if target is parent then remove line\n                if (is_target_parent) {\n                    this.removeLine(this.selection[1], this.selection[0]);\n                }\n\n                // if target is child then setAsConnected line\n                else {\n                    this.setAsConnectedLines(this.selection, \"A\");\n\n                    // check active\n                    this.checkActive();\n                }\n            }\n        }\n    }\n\n    /**\n     * onBlockNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onBlockNodeMouseOver(col_index, row_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selection\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(col_index, row_index, 'source_hover', true);\n            this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', true);\n        }\n\n        // if two selections\n        if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'potential_target', false);\n                this.setNodeClass(col_index, row_index, 'target', true);\n                this.setLineClass(this.selection[0], [col_index, row_index], 'target', true);\n            }\n        }\n\n        // if col changed\n        if (this.bg_col_grid_hover_index !== col_index) {\n\n            //this.bg_col_grid_hover_index = col_index;\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // if 2 selections and new col index is potential\n            //if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [col_index, this.selection[1][1]])) {\n            //    this.selection[1][0] = col_index;\n            //}\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBlockNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onBlockNodeMouseOut(col_index, row_index, exit_side) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selections\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(col_index, row_index, 'source_hover', false);\n            this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', false);\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'target', false);\n                this.setNodeClass(col_index, row_index, 'potential_target', true);\n                this.setLineClass(this.selection[0], [col_index, row_index], 'target', false);\n            }\n        }\n\n        // if this is source selection & source_exit_side not yet set\n        if (_.isEqual(this.selection[0], [col_index, row_index]) && _.isNull(this.source_exit_side)) {\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                // remove 'potential child' class from potential children\n                this.setPotentialChildNodeClasses(col_index, row_index, 'potential_target', false);\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                // remove 'potential child' class from potential parent\n                this.setPotentialParentNodeClasses(col_index, row_index, 'potential_target', false);\n            }\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if one selection one selected\n        if (this.selection.length === 1) {\n\n            // if this is source selection\n            if (_.isEqual(this.selection[0], [col_index, row_index])) {\n\n                // update source exit side\n                this.source_exit_side = exit_side;\n            }\n\n            var target_coords;\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                target_coords = [this.bg_col_grid_hover_index, row_index - 1];\n\n                // if target is potential\n                if (this.isNodePotential([col_index, row_index], target_coords)) {\n                    this.selection.push(target_coords);\n                }\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                var target_row_index = row_index + 1;\n                target_coords = [this.bg_col_grid_hover_index, target_row_index];\n\n                // if not spanning more than one row && target is potential\n                if (Math.abs(this.selection[0][1] - target_row_index) <= 1 && this.isNodePotential([col_index, row_index], target_coords)) {\n\n                    this.selection.push(target_coords);\n                }\n\n            }\n        }\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // grid handlers\n    //-------------------------------------------------\n\n    /**\n     * onRootDeselect\n     */\n    onRootDeselect() {\n\n        // reset source_exit_side\n        this.source_exit_side = null;\n\n        // nothing to do if there are no selections\n        if (this.selection.length === 0) {\n            return true;\n        }\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if selections\n        if (this.selection.length > 0) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // reset if there are not 2 selections\n        if (this.selection.length > 0) {\n            this.selection = [];\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBgColGridMouseOver\n     */\n    onBgColGridMouseOver(index) {\n\n        // do nothing if unchanged\n        if (this.bg_col_grid_hover_index === index) {\n            return true;\n        }\n\n        this.bg_col_grid_hover_index = index;\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            var target_coords = this.source_exit_side === 'top' ? [index, this.selection[0][1] - 1] : [index, this.selection[0][1] + 1];\n\n            // if target is potential\n            if (this.isNodePotential(this.selection[0], target_coords)) {\n                this.selection.push(target_coords);\n            }\n        }\n\n        // if 2 selections and new col index is potential\n        else if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [index, this.selection[1][1]])) {\n            this.selection[1][0] = index;\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onRootMouseLeave\n     *\n     * @param e\n     */\n    onRootMouseLeave() {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        // if 2 selections\n        else if (this.selection.length === 2) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setNodeClass(this.selection[1][0], this.selection[1][1], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        this.selection = [];\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // line handlers\n    //-------------------------------------------------\n\n    /**\n     * onLineRemoveComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineRemoveComplete(source_coords, target_coords, line_index) {\n\n        // update data\n        this.rows[source_coords[1]].columns[source_coords[0]].join.splice(line_index, 1);\n\n        // update blocks\n        var source = this.blocks[source_coords[1]].columns[source_coords[0]];\n\n        // delete line\n        source.lines.splice(line_index, 1);\n\n        // if source block has no more lines then setAsNotConnected\n        if (source.lines.length === 0) {\n\n            // if  block has no parent connections\n            if (!this.doesNodeHaveConnectedParents(source_coords[0], source_coords[1])) {\n                this.setAsNotConnectedBlock([source_coords[0], source_coords[1]]);\n            }\n        }\n\n        // external handler\n        if (!_.isUndefined(this.onLineRemove)) {\n            this.onLineRemove(this.getExternalLineEventHandlerData(source_coords, target_coords, line_index));\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onLineDrawComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineDrawComplete(source_coords, target_coords) {\n\n        var is_block_waiting_for_connection = false;\n\n        _.forEach(this.blocks_waiting_for_connection, (block, index) => {\n            if (_.isEqual(block, target_coords)) {\n                is_block_waiting_for_connection = true;\n                this.blocks_waiting_for_connection.splice(index, 1);\n                return false;\n            }\n        });\n\n        if (is_block_waiting_for_connection) {\n\n            // connect block\n            this.setAsConnectedBlock(target_coords);\n        }\n\n        this.$s.$apply();\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // utils\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // data for external event handlers\n    //-----------------------------\n\n    /**\n     * getExternalNodeEventHandlerData\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {{node: *, data: null}}\n     */\n    getExternalNodeEventHandlerData(col_index, row_index) {\n\n        var data_clone = _.clone(this.rows[row_index].columns[col_index]);\n        var node_clone = _.clone(this.blocks[row_index].columns[col_index]);\n        var result = {\n            node: node_clone,\n            data: null\n        };\n        if (!_.isUndefined(data_clone)) {\n            result.data = data_clone;\n        }\n        return result;\n    }\n\n    /**\n     * getExternalLineEventHandlerData\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     * @returns {{node: *, data: null}}\n     */\n    getExternalLineEventHandlerData(source_coords, target_coords, line_index) {\n\n        var source_data = this.getExternalNodeEventHandlerData(source_coords[0], source_coords[1]);\n        var target_data = this.getExternalNodeEventHandlerData(target_coords[0], target_coords[1]);\n\n        return {\n            source_node: source_data.node,\n            source_data: source_data.data,\n            target_node: target_data.node,\n            target_data: target_data.data,\n            line_index: line_index\n        };\n    }\n\n    //-----------------------------\n    // active check\n    //-----------------------------\n\n    /**\n     * checkActive\n     */\n    checkActive() {\n\n        if (this.blocks.length === 0) {\n            return false;\n        }\n\n        _.forEach(this.blocks[0].columns, (col, col_index) => {\n            if (col.lines.length > 0) {\n                this.activateBlock(col_index, 0);\n            }\n        });\n    }\n\n    /**\n     * activateBlock\n     *\n     * @param col_index\n     * @param row_index\n     */\n    activateBlock(col_index, row_index) {\n\n        var block = this.blocks[row_index].columns[col_index];\n        block.active = true;\n\n        if (block.lines.length > 0) {\n\n            _.forEach(block.lines, (line) => {\n\n                // activate line\n                line.active = true;\n\n                // activate target block\n                this.activateBlock(line.to[0], line.to[1]);\n            });\n        }\n    }\n\n    /**\n     * deactivateBlock\n     *\n     * @param col_index\n     * @param row_index\n     */\n    deactivateBlock(col_index, row_index) {\n\n        var block = this.blocks[row_index].columns[col_index];\n        block.active = false;\n\n        if (block.lines.length > 0) {\n            _.forEach(block.lines, (line) => {\n\n                // deactivate line\n                line.active = false;\n\n                var does_parent_have_active_nodes = this.doesNodeHaveActiveParents(line.to[0], line.to[1]);\n\n                // deactivate target block if no active parents\n                if (!does_parent_have_active_nodes) {\n                    this.deactivateBlock(line.to[0], line.to[1]);\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // node potential\n    //-----------------------------\n\n    /**\n     * doesNodeHaveActiveParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveActiveParents(col_index, row_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        var result = false;\n        var parent_row_index = row_index - 1;\n        var parents = this.blocks[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n            _.forEach(parent.lines, (line) => {\n\n                // if parent coords are not equal to exclude coords\n                // ... and parent has a line to this block\n                // ... and parent is active\n                if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && _.isEqual(line.to, [col_index, row_index]) && parent.active) {\n                    result = true;\n                }\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * doesNodeHaveConnectedParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveConnectedParents(col_index, row_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        if (_.isUndefined(exclude_coords)) {\n            exclude_coords = [];\n        }\n\n        var result = false;\n        var parent_row_index = row_index - 1;\n        var parents = this.blocks[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n\n            // if parent coords are not equal to exclude coords and parent is potential (potential parent node is always connected)\n            if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && this.isNodePotential([col_index, row_index], [parent_col_index, parent_row_index])) {\n\n                result = true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * isNodePotential\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    isNodePotential(source_coords, target_coords) {\n\n        // if not ready\n        if (_.isUndefined(this.blocks[target_coords[1]])) {\n            return false;\n        }\n        if (_.isUndefined(this.blocks[target_coords[1]].columns[target_coords[0]])) {\n            return false;\n        }\n\n        // refuse if control\n        if (this.blocks[target_coords[1]].columns[target_coords[0]].control) {\n            return false;\n        }\n\n        // refuse if same row\n        if (source_coords[1] === target_coords[1]) {\n            return false;\n        }\n\n        // refuse if spanning more than 1 rows\n        if (Math.abs(source_coords[1] - target_coords[1]) > 1) {\n            return false;\n        }\n\n        // target row index out of bounds check\n        if (target_coords[1] >= this.blocks.length) {\n            return false;\n        }\n\n        // target col index out of bounds check\n        if (target_coords[0] >= this.blocks[target_coords[1]].columns.length) {\n            return false;\n        }\n\n        // check if target is parent or child\n        var is_target_parent = target_coords[1] < source_coords[1];\n        var source = this.blocks[source_coords[1]].columns[source_coords[0]];\n        var target = this.blocks[target_coords[1]].columns[target_coords[0]];\n        var result;\n\n        // if target is parent, then check if target has connected lines to source\n        if (is_target_parent) {\n\n            result = false;\n\n            // check that last exit was not bottom\n            if (this.source_exit_side === 'bottom') {\n                return false;\n            }\n\n            // check if target has an connected line from it source\n            _.forEach(target.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, source_coords)) {\n                    result = true;\n                    return false;\n                }\n            });\n        }\n\n        // if target is child, then\n        else {\n\n            result = true;\n\n            // check that last exit was not top\n            if (this.source_exit_side === 'top') {\n                return false;\n            }\n\n            // check if source does not have an connected line to it\n            _.forEach(source.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, target_coords)) {\n                    result = false;\n                    return false;\n                }\n            });\n        }\n\n        return result;\n    }\n\n    //-----------------------------\n    // node classes\n    //-----------------------------\n\n    /**\n     * setLineClass\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param key\n     * @param value\n     */\n    setLineClass(source_coords, target_coords, key, value) {\n\n        // loop child row columns\n        _.forEach(this.blocks[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            // if child node is potential then update class property\n            if (_.isEqual(line.to, target_coords)) {\n                line[key] = value;\n            }\n        });\n    }\n\n    /**\n     * setNodeClass\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setNodeClass(col_index, row_index, key, value) {\n        if (_.has(this.blocks[row_index].columns[col_index], key)) {\n            this.blocks[row_index].columns[col_index][key] = value;\n        }\n    }\n\n    /**\n     * setPotentialNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialNodeClasses(col_index, row_index, key, value) {\n\n        this.setPotentialChildNodeClasses(col_index, row_index, key, value);\n        this.setPotentialParentNodeClasses(col_index, row_index, key, value);\n    }\n\n    /**\n     * setPotentialChildNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialChildNodeClasses(col_index, row_index, key, value) {\n\n        // if child row is not out of bounds\n        if ((row_index + 1) < (this.blocks.length)) {\n\n            // loop child row columns\n            _.forEach(this.blocks[row_index + 1].columns, (child_col, child_col_index) => {\n\n                // if child node is potential then update class property\n                if (this.isNodePotential([col_index, row_index], [child_col_index, row_index + 1])) {\n                    child_col[key] = value;\n                }\n            });\n        }\n    }\n\n    /**\n     * setPotentialParentNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialParentNodeClasses(col_index, row_index, key, value) {\n\n        if (row_index > 0) {\n\n            // loop parent node columns\n            _.forEach(this.blocks[row_index - 1].columns, (parent_col, parent_col_index) => {\n\n                // if parent node is potential then update class property\n                if (this.isNodePotential([col_index, row_index], [parent_col_index, row_index - 1])) {\n                    parent_col[key] = value;\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // viewport\n    //-----------------------------\n\n    /**\n     * setViewport\n     *\n     * @param cols\n     * @param rows\n     */\n    setViewport(cols, rows) {\n\n        var total_item_width = BLOCK_WIDTH + COL_SPACING;\n        var total_item_height = BLOCK_HEIGHT + ROW_SPACING;\n\n        this.viewport_width = total_item_width * cols;\n        this.viewport_height = total_item_height * rows;\n\n        this.viewport_style = {\n            'background-color': \"#ccc\",\n            'min-width': this.viewport_width + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.wrapper_style = {\n            'max-width': (this.viewport_width + MAX_VIEWPORT_WIDTH_INCREASE) + \"px\",\n            'min-width': this.viewport_width + \"px\",\n            'max-height': (this.viewport_height + (MAX_VIEWPORT_HEIGHT_INCREASE * rows)) + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.viewport_viewbox = \" 0 0 \" + this.viewport_width + \" \" + this.viewport_height;\n    }\n\n    /**\n     * checkViewport\n     *\n     * @param col_index\n     * @param row_index\n     */\n    checkViewport(col_index, row_index) {\n\n        var should_update_viewport = false;\n\n        // row bounds check\n        if (row_index >= this.grid_row_count) {\n\n            // increase rowspan\n            this.grid_row_count++;\n            should_update_viewport = true;\n        }\n\n        // col bounds check\n        if (col_index >= this.grid_col_count) {\n\n            // increase colspan\n            this.grid_col_count++;\n            should_update_viewport = true;\n\n            // add bg grid col\n            this.addBgGridCol(this.grid_col_count - 1);\n        }\n\n        // set viewport\n        if (should_update_viewport) {\n            this.setViewport(this.grid_col_count, this.grid_row_count);\n        }\n    }\n\n    //-----------------------------\n    // coords\n    //-----------------------------\n\n    /**\n     * calculateColX\n     *\n     * @param index\n     */\n    calculateColX(index) {\n        if (index === 0) {\n            return 0;\n        }\n        var first_col_width = BLOCK_WIDTH + (COL_SPACING / 2);\n        var col_width = BLOCK_WIDTH + (COL_SPACING);\n        return first_col_width + ((index - 1) * col_width);\n    }\n\n    /**\n     * calculateColWidth\n     *\n     * @param index\n     */\n    calculateColWidth(index) {\n        var total_item_width = index === 0 ? BLOCK_WIDTH + (COL_SPACING / 2) : BLOCK_WIDTH + COL_SPACING;\n        return total_item_width;\n    }\n\n    /**\n     * calculateRowY\n     *\n     * @param index\n     */\n    calculateRowY(index) {\n        var row_height = BLOCK_HEIGHT + ROW_SPACING;\n        return index * row_height;\n    }\n\n    /**\n     * calculateRowHeight\n     *\n     * @param index\n     */\n    calculateRowHeight() {\n        return BLOCK_HEIGHT + ROW_SPACING;\n    }\n\n    //-----------------------------\n    // drawing\n    //-----------------------------\n\n    /**\n     * addLine\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    addLine(source_coords, target_coords, connected) {\n\n        // check bounds\n        if (target_coords[1] >= this.blocks.length) {\n            return false;\n        }\n\n        // get coords\n        var source_lock_coords = Utils.getCoords(source_coords[0], source_coords[1], BLOCK_BOTTOM);\n        var target_lock_coords = Utils.getCoords(target_coords[0], target_coords[1], BLOCK_TOP);\n\n        // add line properties\n        this.blocks[source_coords[1]].columns[source_coords[0]].lines.push({\n            connected: !_.isUndefined(connected) ? connected : false,\n            from: source_coords,\n            to: target_coords,\n            x1: source_lock_coords[0],\n            y1: source_lock_coords[1],\n            x2: target_lock_coords[0],\n            y2: target_lock_coords[1]\n        });\n\n        if (connected) {\n            // update data\n            this.rows[source_coords[1]].columns[source_coords[0]].join.push(target_coords[0]);\n        }\n    }\n\n    /**\n     * updateLineTarget\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    updateLineTarget(source_coords, target_coords) {\n\n        // get target lock coords\n        var target_lock_coords = Utils.getCoords(target_coords[0], target_coords[1], BLOCK_TOP);\n\n        // find line\n        _.forEach(this.blocks[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.to = target_coords;\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeLine\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    removeLine(source_coords, target_coords) {\n\n        // get target lock coords\n        var target_lock_coords = Utils.getCoords(source_coords[0], source_coords[1], BLOCK_BOTTOM);\n\n        // find line\n        _.forEach(this.blocks[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                var block = this.blocks[target_coords[1]].columns[target_coords[0]];\n                var block_has_connected_parents = this.doesNodeHaveConnectedParents(target_coords[0], target_coords[1], source_coords);\n\n                // if block has no lines & has no parent connections\n                if (block.lines.length === 0 && !block_has_connected_parents) {\n                    // set as not connected\n                    this.setAsNotConnectedBlock(target_coords);\n                }\n\n                // if block has no parent connections\n                var block_has_active_parents = this.doesNodeHaveActiveParents(target_coords[0], target_coords[1], source_coords);\n\n                if (!block_has_active_parents) {\n\n                    // deactivate block\n                    this.deactivateBlock(target_coords[0], target_coords[1]);\n                }\n\n                // set line properties\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.previous_to = line.to; // TODO: this feels a bit hacky\n                line.to = [source_coords[0], source_coords[1]];\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeUnconnectedLines\n     *\n     * @param selection\n     */\n    removeUnconnectedLines(selection) {\n\n        _.forEach(this.blocks[selection[0][1]].columns[selection[0][0]].lines, (line) => {\n            if (!line.connected) {\n                this.removeLine(this.selection[0], this.selection[1]);\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedLines\n     *\n     * @param selection\n     */\n    setAsConnectedLines(selection) {\n\n        _.forEach(this.blocks[selection[0][1]].columns[selection[0][0]].lines, (line, line_index) => {\n            if (!line.connected) {\n\n                // setAsConnected line\n                line.connected = true;\n\n                // setAsConnected blocks\n                this.setAsConnectedBlock(line.from);\n                this.setAsConnectedBlock(line.to);\n\n                // update data\n                this.rows[line.from[1]].columns[line.from[0]].join.splice(line_index, 0, line.to[0]);\n\n                // external handler\n                if (!_.isUndefined(this.onLineAdd)) {\n                    this.onLineAdd(this.getExternalLineEventHandlerData(line.from, line.to, line_index));\n                }\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedBlock\n     *\n     * @param coords\n     */\n    setAsConnectedBlock(coords) {\n        this.blocks[coords[1]].columns[coords[0]].connected = true;\n    }\n\n    /**\n     * setAsNotConnectedBlock\n     *\n     * @param coords\n     */\n    setAsNotConnectedBlock(coords) {\n        this.blocks[coords[1]].columns[coords[0]].connected = false;\n    }\n\n    /**\n     * addBlock\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     * @param lines\n     * @returns {boolean}\n     */\n    addBlock(col_index, row_index, label, lines) {\n\n        if (row_index > this.blocks.length) {\n            throw new Error(\"Invalid row index\");\n        }\n\n        // create row if it doesn't exist\n        if (row_index === this.blocks.length) {\n            this.blocks.push({columns: []});\n        }\n\n        // if block already exists (control) then remove and re-add after block\n        var removed_block;\n\n        if (!_.isUndefined(this.blocks[row_index].columns[col_index])) {\n            removed_block = this.blocks[row_index].columns.splice(col_index, 1);\n        }\n\n        // get top left coords\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n\n        // lines\n        var block_lines = [];\n        var line_source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_BOTTOM);\n\n        _.forEach(lines, (line_target_col_index) => {\n\n            var line_target_coords = [line_target_col_index, row_index + 1];\n            var line_target_lock_coords = Utils.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP);\n\n            block_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set blocks as connected\n            this.blocks_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set block properties\n        var block = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + LABEL_SPACING,\n            label_y: top_left_coords[1] + LABEL_SPACING,\n            label: label,\n            connected: block_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: block_lines\n        };\n\n        // add block\n        this.blocks[row_index].columns.push(block);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n        // replace removed block\n        if (!_.isUndefined(removed_block)) {\n            this.addControl(removed_block[0].row_index);\n        }\n    }\n\n    /**\n     * updateBlock\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     */\n    updateBlock(col_index, row_index, label) {\n\n        // update label\n        if (!_.isUndefined(label) && this.blocks[row_index].columns[col_index].label !== label) {\n            this.blocks[row_index].columns[col_index].label = label;\n        }\n\n        // // update lines\n        // if (!_.isUndefined(lines)) {\n        //\n        //     var line_source_lock_coords     = Utils.getCoords(col_index, row_index, BLOCK_BOTTOM);\n        //\n        //     _.forEach(lines, (line_target_col_index) => {\n        //\n        //         var line_target_coords = [line_target_col_index, row_index + 1];\n        //         var line_target_lock_coords     = Utils.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP);\n        //\n        //         this.blocks[row_index].columns[col_index].lines.push({\n        //             connected: true,\n        //             from: [col_index, row_index],\n        //             to: line_target_coords,\n        //             x1: line_source_lock_coords[0],\n        //             y1: line_source_lock_coords[1],\n        //             x2: line_target_lock_coords[0],\n        //             y2: line_target_lock_coords[1]\n        //         });\n        //\n        //         this.setNodeClass(col_index, row_index, 'connected', true);\n        //\n        //         // set blocks as connected\n        //         this.blocks_waiting_for_connection.push(line_target_coords);\n        //     });\n        // }\n    }\n\n    /**\n     * removeBlock\n     *\n     * @param col_index\n     * @param row_index\n     */\n    removeBlock(col_index, row_index) {\n\n        if (row_index >= this.blocks.length) {\n            return true;\n        }\n\n        if (col_index >= this.blocks[row_index].columns.length - 1) {\n            return true;\n        }\n\n        // remove lines\n        _.forEach(this.blocks[row_index].columns[col_index].lines, (line) => {\n            this.removeLine(line.from, line.to);\n        });\n\n        // remove block\n        this.blocks[row_index].columns.splice(col_index, 1);\n\n        // update data\n        this.rows[row_index].columns.splice(col_index, 1);\n\n        // update siblings\n        for (var i = col_index; i < (this.blocks[row_index].columns.length); i++) {\n            this.updateBlockAfterSiblingAddedOrRemoved(i, row_index);\n\n            // if not last column (control)\n            if (i < this.blocks[row_index].columns.length - 1) {\n                this.rows[row_index].columns[i].data.ui_column_index = i;\n                this.rows[row_index].columns[i].data.ui_row_index = row_index;\n            }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            var parent_row_index = row_index - 1;\n            _.forEach(this.blocks[parent_row_index].columns, (column, parent_col_index) => {\n                _.forEach(column.lines, (line, line_index) => {\n\n                    // if parent connects to this node\n                    if (_.isEqual(line.to, [col_index, row_index])) {\n                        column.lines.splice(line_index, 1);\n\n                        // update data\n                        this.rows[parent_row_index].columns[parent_col_index].join.splice(line_index, 1);\n\n                        // if parent no longer has any lines\n                        if (column.lines.length === 0) {\n                            this.setAsNotConnectedBlock([parent_col_index, parent_row_index]);\n                        }\n                    }\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] > col_index) {\n\n                        // update lines target\n                        var new_line_to = [line.to[0] - 1, line.to[1]];\n\n                        // get target lock coords\n                        var target_lock_coords = Utils.getCoords(new_line_to[0], new_line_to[1], BLOCK_TOP);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n        }\n\n        // update children\n        if (row_index !== this.rows.length - 1) {\n            var children_row_index = row_index + 1;\n            _.forEach(this.blocks[children_row_index].columns, (column, children_col_index) => {\n\n                // if  block has no parent connections\n                if (!this.doesNodeHaveConnectedParents(children_col_index, children_row_index)) {\n                    this.setAsNotConnectedBlock([children_col_index, children_row_index]);\n                }\n            });\n        }\n    }\n\n    /**\n     * insertBlock\n     *\n     * @param col_index\n     * @param row_index\n     * @param data\n     */\n    insertBlock(col_index, row_index, data) {\n\n        if (row_index >= this.blocks.length) {\n            return true;\n        }\n\n        if (col_index > this.blocks[row_index].columns.length - 1) {\n            return true;\n        }\n\n        // get top left coords\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n\n        // lines\n        var block_lines = [];\n        var line_source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_BOTTOM);\n\n        _.forEach(data.join, (line_target_col_index) => {\n\n            var line_target_coords = [line_target_col_index, row_index + 1];\n            var line_target_lock_coords = Utils.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP);\n\n            block_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set blocks as connected\n            this.blocks_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set block properties\n        var block = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + LABEL_SPACING,\n            label_y: top_left_coords[1] + LABEL_SPACING,\n            label: data.label,\n            connected: block_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: block_lines\n        };\n\n        // insert block\n        this.blocks[row_index].columns.splice(col_index, 0, block);\n\n        // update data\n        this.rows[row_index].columns.splice(col_index, 0, data);\n\n        // update siblings\n        for (var i = col_index + 1; i < (this.blocks[row_index].columns.length); i++) {\n\n            this.updateBlockAfterSiblingAddedOrRemoved(i, row_index);\n\n            // if not last column (control)\n            if (i < this.blocks[row_index].columns.length - 1) {\n                this.rows[row_index].columns[i].data.ui_column_index = i;\n                this.rows[row_index].columns[i].data.ui_row_index = row_index;\n            }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            var parent_row_index = row_index - 1;\n            _.forEach(this.blocks[parent_row_index].columns, (column) => {\n                _.forEach(column.lines, (line) => {\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] >= col_index) {\n\n                        // update lines target\n                        var new_line_to = [line.to[0] + 1, line.to[1]];\n\n                        // get target lock coords\n                        var target_lock_coords = Utils.getCoords(new_line_to[0], new_line_to[1], BLOCK_TOP);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * updateBlockAfterSiblingAddedOrRemoved\n     *\n     * @param {Integer}    col_index\n     * @param {Integer}    row_index\n     */\n    updateBlockAfterSiblingAddedOrRemoved(col_index, row_index) {\n\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n        var center_coords = Utils.getCoords(col_index, row_index, BLOCK_CENTER);\n\n        // update block\n\n        this.blocks[row_index].columns[col_index].col_index = col_index;\n        this.blocks[row_index].columns[col_index].coords = top_left_coords;\n        this.blocks[row_index].columns[col_index].x = top_left_coords[0];\n        this.blocks[row_index].columns[col_index].y = top_left_coords[1];\n\n        // update labels\n        // last block has different label position\n        if (col_index === (this.blocks[row_index].columns.length - 1)) {\n            this.blocks[row_index].columns[col_index].label_x = center_coords[0];\n            this.blocks[row_index].columns[col_index].label_y = center_coords[1];\n        } else {\n            this.blocks[row_index].columns[col_index].label_x = top_left_coords[0] + LABEL_SPACING;\n            this.blocks[row_index].columns[col_index].label_y = top_left_coords[1] + LABEL_SPACING;\n        }\n\n        // update lines\n        _.forEach(this.blocks[row_index].columns[col_index].lines, (line) => {\n\n            // get target lock coords\n            var source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * updateBlockAfterChildAddedOrRemoved\n     *\n     * @param {Integer}    col_index\n     * @param {Integer}    row_index\n     */\n    updateBlockAfterChildAddedOrRemoved(col_index, row_index) {\n\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n        var center_coords = Utils.getCoords(col_index, row_index, BLOCK_CENTER);\n\n        // update block\n\n        this.blocks[row_index].columns[col_index].col_index = col_index;\n        this.blocks[row_index].columns[col_index].coords = top_left_coords;\n        this.blocks[row_index].columns[col_index].x = top_left_coords[0];\n        this.blocks[row_index].columns[col_index].y = top_left_coords[1];\n\n        // update labels\n        // last block has different label position\n        if (col_index === (this.blocks[row_index].columns.length - 1)) {\n            this.blocks[row_index].columns[col_index].label_x = center_coords[0];\n            this.blocks[row_index].columns[col_index].label_y = center_coords[1];\n        } else {\n            this.blocks[row_index].columns[col_index].label_x = top_left_coords[0] + LABEL_SPACING;\n            this.blocks[row_index].columns[col_index].label_y = top_left_coords[1] + LABEL_SPACING;\n        }\n\n        // update lines\n        _.forEach(this.blocks[row_index].columns[col_index].lines, (line) => {\n\n            // get target lock coords\n            var source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * addControl\n     *\n     * @param {Integer}    row_index\n     */\n    addControl(row_index) {\n\n        // create row if it doesn't exist\n        if (row_index === this.blocks.length) {\n            this.blocks.push({columns: []});\n        }\n\n        // validate row index\n        if (row_index >= this.blocks.length) {\n            throw new Error(\"Invalid row index\");\n        }\n\n        var col_index = this.blocks[row_index].columns.length;\n\n        // get top left coords\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n        var center_coords = Utils.getCoords(col_index, row_index, BLOCK_CENTER);\n\n        // set block properties\n        var block = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: center_coords[0],\n            label_y: center_coords[1],\n            label: \"+\",\n            connected: false,\n            control: true,\n            row_index: row_index,\n            col_index: col_index,\n            lines: []\n        };\n\n        // add block\n        this.blocks[row_index].columns.push(block);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n    }\n\n    /**\n     * addBgGridCol\n     *\n     * @param {Integer}    index\n     */\n    addBgGridCol(index) {\n\n        this.bg_col_grid.push({\n            index: index,\n            x: this.calculateColX(index),\n            width: this.calculateColWidth(index)\n        });\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // init / update\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * init\n     *\n     * @param data\n     * @param column_property_name\n     */\n    init(data, column_property_name) {\n\n        // add placeholders\n        for (var row_index = 0; row_index < INITIAL_GRID_ROWS; row_index++) {\n\n            // add data placeholder\n            if (row_index >= data.length) {\n                data.push({columns: []});\n            }\n        }\n\n        // add blocks\n        _.forEach(data, (row, row_index) => {\n\n            _.forEach(row[column_property_name], (col, col_index) => {\n\n                // add block\n                this.addBlock(col_index, row_index, col.label, col.join);\n            });\n\n            // add control\n            this.addControl(row_index);\n        });\n\n        // add bg_col_grid array\n        _.map(new Array(this.grid_col_count), (col, index) => {\n\n            // add bg grid col\n            this.addBgGridCol(index);\n        });\n\n        // set viewport\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        // check active\n        this.checkActive();\n    }\n\n    /**\n     * update\n     *\n     * @param data\n     * @param column_property_name\n     */\n    update(data, column_property_name) {\n\n        // add controls\n        _.forEach(data, (row, row_index) => {\n\n            // ... if row index exceeds or equals current UI rows\n            if (row_index >= this.blocks.length) {\n                this.addControl(row_index);\n            }\n        });\n\n        // add blocks\n        _.forEach(data, (row, row_index) => {\n            _.forEach(row[column_property_name], (col, col_index) => {\n\n                // update block\n                this.updateBlock(col_index, row_index, col.label);\n\n                // ... if column index exceeds or equals current UI cols (excluding control)\n                if (col_index >= this.blocks[row_index].columns.length - 1) {\n                    var label = _.has(col, 'label') ? col.label : \"\";\n                    var lines = _.has(col, 'join') ? col.join : [];\n                    this.addBlock(col_index, row_index, label, lines);\n                }\n            });\n        });\n\n        // set viewport\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        // check active\n        this.checkActive();\n    }\n}\n\nAngularSvgNodesController.$inject = [ '$scope' ];"],"sourceRoot":"src/app/*.js"}