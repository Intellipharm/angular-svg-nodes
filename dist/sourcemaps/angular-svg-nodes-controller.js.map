{"version":3,"sources":["angular-svg-nodes-controller.js"],"names":[],"mappings":"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","file":"angular-svg-nodes-controller.js","sourcesContent":["import {\n    BLOCK_TOP_LEFT,\n    BLOCK_TOP,\n    BLOCK_CENTER,\n    BLOCK_BOTTOM,\n    ACTION_ADD,\n    ACTION_REMOVE,\n    ACTION_UPDATE,\n    INITIAL_GRID_COLS,\n    INITIAL_GRID_ROWS,\n    BLOCK_WIDTH,\n    BLOCK_HEIGHT,\n    COL_SPACING,\n    ROW_SPACING,\n    LABEL_SPACING,\n    DISABLE_CONTROL_NODES,\n    MAX_VIEWPORT_WIDTH_INCREASE,\n    MAX_VIEWPORT_HEIGHT_INCREASE\n} from \"./angular-svg-nodes-settings\";\n\nimport * as Utils from './angular-svg-nodes-utils';\n\nexport default class AngularSvgNodesController {\n\n    constructor($s) {\n\n        this.$s = $s;\n\n        //-----------------------------\n        // directives vars\n        //-----------------------------\n        //\n        // this.initial_state\n        // this.api\n        //\n        //-----------------------------\n\n        if (_.isUndefined(this.api)) {\n            this.api = {};\n        }\n\n        //-----------------------------\n        // state\n        //-----------------------------\n\n        this.state = [];\n\n        //-----------------------------\n        // config\n        //-----------------------------\n\n        this.config = {\n            initial_grid_cols: !_.isUndefined(this.config_initial_grid_cols) ? this.config_initial_grid_cols : INITIAL_GRID_COLS,\n            initial_grid_rows: !_.isUndefined(this.config_initial_grid_rows) ? this.config_initial_grid_rows : INITIAL_GRID_ROWS,\n            block_width: !_.isUndefined(this.config_block_width) ? this.config_block_width : BLOCK_WIDTH,\n            block_height: !_.isUndefined(this.config_block_height) ? this.config_block_height : BLOCK_HEIGHT,\n            col_spacing: !_.isUndefined(this.config_col_spacing) ? this.config_col_spacing : COL_SPACING,\n            row_spacing: !_.isUndefined(this.config_row_spacing) ? this.config_row_spacing : ROW_SPACING,\n            label_spacing: !_.isUndefined(this.config_label_spacing) ? this.config_label_spacing : LABEL_SPACING,\n            disable_control_nodes: !_.isUndefined(this.config_disable_control_nodes) ? this.config_disable_control_nodes : DISABLE_CONTROL_NODES,\n            max_viewport_width_increase: !_.isUndefined(this.config_max_viewport_width_increase) ? this.config_max_viewport_width_increase : MAX_VIEWPORT_WIDTH_INCREASE,\n            max_viewport_height_increase: !_.isUndefined(this.config_max_viewport_height_increase) ? this.config_max_viewport_height_increase : MAX_VIEWPORT_HEIGHT_INCREASE,\n        };\n\n        //-----------------------------\n        // control\n        //-----------------------------\n\n        // an array of block coords that will be set as connected on teh line\n        this.blocks_waiting_for_connection = [];\n\n        // parent coordinates (for reference)\n        this.parent_coords = [];\n\n        // view coordinates (for reference)\n        this.coords = [];\n\n        // view element data\n        this.blocks = [];\n\n        // array for bg grid\n        this.bg_col_grid = [];\n        this.bg_col_grid_hover_index = null;\n\n        // grid dimmensions\n        this.grid_col_count = this.config.initial_grid_cols;\n        this.grid_row_count = this.config.initial_grid_rows;\n        this.label_width = this.config.block_width - (this.config.label_spacing * 2);\n        this.label_height = this.config.block_height - (this.config.label_spacing * 2);\n\n        // viewport style & bounds\n        this.wrapper_style = \"\";\n        this.viewport_style = \"\";\n        this.viewport_width = 0;\n        this.viewport_height = 0;\n        this.viewport_viewbox = \"\";\n\n        // node selections\n        this.selection = [];\n        this.source_exit_side = null;\n\n        // active node\n        this.selected_node = [];\n\n        ////////////////////////////////////////////////\n        //\n        // watchers\n        //\n        ////////////////////////////////////////////////\n\n        this.$s.$watch('AngularSvgNodes.selection', (newValue, oldValue) => {\n\n            if (!_.isUndefined(newValue)) {\n\n                // two selected & target is child of source\n                if (newValue.length === 2 && newValue[1][1] > newValue[0][1]) {\n\n                    // new target selection\n                    if (newValue.length > oldValue.length) {\n\n                        // add line\n                        this.addLine(this.selection[0], this.selection[1]);\n                    }\n\n                    // updated target selection\n                    else {\n\n                        // update line\n                        this.updateLineTarget(this.selection[0], this.selection[1]);\n                    }\n                }\n            }\n        }, true);\n\n        ////////////////////////////////////////////////\n        //\n        // api\n        //\n        ////////////////////////////////////////////////\n\n        /**\n         * addRow\n         *\n         * @param label\n         */\n        this.api.addRow = (label = \"\") => {\n            let _row_index = this.blocks.length;\n            let _col_index = 0;\n            this.addBlock(_col_index, _row_index, label, []);\n        };\n\n        /**\n         * setNodeLabel\n         *\n         * @param row_index\n         * @param col_index\n         * @param label\n         */\n        this.api.setNodeLabel = (row_index, col_index, label) => {\n\n            if (row_index >= this.blocks.length) {\n                console.error(\"AngularSvgNodes Error : invalid row index provided to setNodeLabel\");\n                return;\n            }\n\n            if (col_index >= this.blocks[row_index].columns.length) {\n                console.error(\"AngularSvgNodes Error : invalid col index provided to setNodeLabel\");\n                return;\n            }\n\n            this.updateBlock(col_index, row_index, label);\n        };\n\n        /**\n         * setNodeHighlight\n         *\n         * @param row_index\n         * @param col_index\n         * @param value\n         */\n        this.api.setNodeHighlight = (row_index, col_index, value) => {\n\n            if (row_index >= this.blocks.length) {\n                console.error(\"AngularSvgNodes Error : invalid row index provided to setNodeHighlight\");\n                return;\n            }\n\n            if (col_index >= this.blocks[row_index].columns.length) {\n                console.error(\"AngularSvgNodes Error : invalid col index provided to setNodeHighlight\");\n                return;\n            }\n\n            this.blocks[row_index].columns[col_index].highlight = value;\n        };\n\n        ////////////////////////////////////////////////\n        //\n        // init\n        //\n        ////////////////////////////////////////////////\n\n        this.init();\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // init\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * init\n     */\n    init() {\n\n        let _column_property_name = 'columns';\n        let _data = !_.isUndefined(this.initial_state) ?  this.initial_state : [];\n\n        // add placeholders\n        for (var row_index = 0; row_index < this.config.initial_grid_rows; row_index++) {\n\n            // add data placeholder\n            if (row_index >= _data.length) {\n                _data.push({columns: []});\n            }\n        }\n\n        // add blocks\n        _.forEach(_data, (row, row_index) => {\n\n            _.forEach(row[ _column_property_name ], (col, col_index) => {\n\n                // add block\n                this.addBlock(col_index, row_index, col.label, col.join);\n            });\n\n            // add control\n            this.addControl(row_index);\n        });\n\n        // add bg_col_grid array\n        _.map(new Array(this.grid_col_count), (col, index) => {\n\n            // add bg grid col\n            this.addBgGridCol(index);\n        });\n\n        // set viewport\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        // check active\n        this.checkActive();\n\n        // update\n        this.update(_data, _column_property_name);\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // handlers\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // general\n    //-----------------------------\n\n    /**\n     * onNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeSelect(col_index, row_index) {\n\n        // external handler\n        if (!_.isUndefined(this.onNodeMouseDown)) {\n            this.onNodeMouseDown(this.getExternalNodeEventHandlerData(col_index, row_index));\n        }\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            if (!this.config.disable_control_nodes) {\n                this.onControlNodeSelect(col_index, row_index);\n            }\n            return true;\n        }\n\n        // if block\n        this.onBlockNodeSelect(col_index, row_index);\n\n        if (!_.isUndefined(this.onNodeSelectionCallback)) {\n            this.onNodeSelectionCallback({ col_index, row_index });\n        }\n    }\n\n    /**\n     * onNodeDeselect\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeDeselect(col_index, row_index) {\n\n        // external handler\n        if (!_.isUndefined(this.onNodeMouseUp)) {\n            this.onNodeMouseUp(this.getExternalNodeEventHandlerData(col_index, row_index));\n        }\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            return false;\n        }\n\n        // if block\n        this.onBlockNodeDeselect(col_index, row_index);\n    }\n\n    /**\n     * onNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeMouseOver(col_index, row_index) {\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            this.onControlNodeMouseOver(col_index, row_index);\n            return true;\n        }\n\n        // if block\n        this.onBlockNodeMouseOver(col_index, row_index);\n    }\n\n    /**\n     * onNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeMouseOut(col_index, row_index, exit_side) {\n\n        // if control\n        if (this.blocks[row_index].columns[col_index].control) {\n            this.onControlNodeMouseOut(col_index, row_index);\n            return true;\n        }\n\n        // if block\n        this.onBlockNodeMouseOut(col_index, row_index, exit_side);\n    }\n\n    //-------------------------------------------------\n    // control node handlers\n    //-------------------------------------------------\n\n    /**\n     * onControlNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onControlNodeSelect(col_index, row_index) {\n\n        this.addBlock(col_index, row_index, \"NEW\", []);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onControlNodeMouseOver(col_index, row_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(col_index, row_index, 'control_hover', true);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onControlNodeMouseOut(col_index, row_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(col_index, row_index, 'control_hover', false);\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // block node handlers\n    //-------------------------------------------------\n\n    /**\n     * onBlockNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onBlockNodeSelect(col_index, row_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        this.setNodeClass(col_index, row_index, 'source_hover', false);\n        this.setNodeClass(col_index, row_index, 'source', true);\n        this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', false);\n        this.setPotentialNodeClasses(col_index, row_index, 'potential_target', true);\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // set selection\n        this.selection = [[col_index, row_index]];\n        this.selected_node = [col_index, row_index];\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBlockNodeDeselect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onBlockNodeDeselect(col_index, row_index) {\n\n        // reset last exit side\n        this.source_exit_side = null;\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if one selection\n        if (this.selection.length === 1) {\n\n            // if deselecting on current source\n            if (_.isEqual(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'source', false);\n                this.setNodeClass(col_index, row_index, 'source_hover', true);\n                this.setPotentialNodeClasses(col_index, row_index, 'potential_target', false);\n                this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', true);\n            }\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if deselecting on current target (& is potential ?)\n            if (_.isEqual(this.selection[1], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'target', false);\n\n                // if  block has no parent connections\n                if (!this.doesNodeHaveConnectedParents(col_index, row_index)) {\n                    this.setPotentialNodeClasses(col_index, row_index, 'potential_target', false);\n                }\n\n                // check active\n                this.checkActive();\n            }\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // if deselecting on current target & is potential\n            if (_.isEqual(this.selection[1], [col_index, row_index]) && this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                var is_target_parent = this.selection[0][1] > row_index;\n\n                // if target is parent then remove line\n                if (is_target_parent) {\n                    this.removeLine(this.selection[1], this.selection[0]);\n                }\n\n                // if target is child then setAsConnected line\n                else {\n                    this.setAsConnectedLines(this.selection, \"A\");\n\n                    // check active\n                    this.checkActive();\n                }\n            }\n        }\n    }\n\n    /**\n     * onBlockNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onBlockNodeMouseOver(col_index, row_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selection\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(col_index, row_index, 'source_hover', true);\n            this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', true);\n        }\n\n        // if two selections\n        if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'potential_target', false);\n                this.setNodeClass(col_index, row_index, 'target', true);\n                this.setLineClass(this.selection[0], [col_index, row_index], 'target', true);\n            }\n        }\n\n        // if col changed\n        if (this.bg_col_grid_hover_index !== col_index) {\n\n            //this.bg_col_grid_hover_index = col_index;\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // if 2 selections and new col index is potential\n            //if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [col_index, this.selection[1][1]])) {\n            //    this.selection[1][0] = col_index;\n            //}\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBlockNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onBlockNodeMouseOut(col_index, row_index, exit_side) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selections\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(col_index, row_index, 'source_hover', false);\n            this.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', false);\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(col_index, row_index, 'target', false);\n                this.setNodeClass(col_index, row_index, 'potential_target', true);\n                this.setLineClass(this.selection[0], [col_index, row_index], 'target', false);\n            }\n        }\n\n        // if this is source selection & source_exit_side not yet set\n        if (_.isEqual(this.selection[0], [col_index, row_index]) && _.isNull(this.source_exit_side)) {\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                // remove 'potential child' class from potential children\n                this.setPotentialChildNodeClasses(col_index, row_index, 'potential_target', false);\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                // remove 'potential child' class from potential parent\n                this.setPotentialParentNodeClasses(col_index, row_index, 'potential_target', false);\n            }\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if one selection one selected\n        if (this.selection.length === 1) {\n\n            // if this is source selection\n            if (_.isEqual(this.selection[0], [col_index, row_index])) {\n\n                // update source exit side\n                this.source_exit_side = exit_side;\n            }\n\n            var target_coords;\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                target_coords = [this.bg_col_grid_hover_index, row_index - 1];\n\n                // if target is potential\n                if (this.isNodePotential([col_index, row_index], target_coords)) {\n                    this.selection.push(target_coords);\n                }\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                var target_row_index = row_index + 1;\n                target_coords = [this.bg_col_grid_hover_index, target_row_index];\n\n                // if not spanning more than one row && target is potential\n                if (Math.abs(this.selection[0][1] - target_row_index) <= 1 && this.isNodePotential([col_index, row_index], target_coords)) {\n\n                    this.selection.push(target_coords);\n                }\n\n            }\n        }\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // grid handlers\n    //-------------------------------------------------\n\n    /**\n     * onRootDeselect\n     */\n    onRootDeselect() {\n\n        // reset source_exit_side\n        this.source_exit_side = null;\n\n        // nothing to do if there are no selections\n        if (this.selection.length === 0) {\n            return true;\n        }\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if selections\n        if (this.selection.length > 0) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // reset if there are not 2 selections\n        if (this.selection.length > 0) {\n            this.selection = [];\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBgColGridMouseOver\n     */\n    onBgColGridMouseOver(index) {\n\n        // do nothing if unchanged\n        if (this.bg_col_grid_hover_index === index) {\n            return true;\n        }\n\n        this.bg_col_grid_hover_index = index;\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            var target_coords = this.source_exit_side === 'top' ? [index, this.selection[0][1] - 1] : [index, this.selection[0][1] + 1];\n\n            // if target is potential\n            if (this.isNodePotential(this.selection[0], target_coords)) {\n                this.selection.push(target_coords);\n            }\n        }\n\n        // if 2 selections and new col index is potential\n        else if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [index, this.selection[1][1]])) {\n            this.selection[1][0] = index;\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onRootMouseLeave\n     *\n     * @param e\n     */\n    onRootMouseLeave() {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        // if 2 selections\n        else if (this.selection.length === 2) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setNodeClass(this.selection[1][0], this.selection[1][1], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        this.selection = [];\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // line handlers\n    //-------------------------------------------------\n\n    /**\n     * onLineRemoveComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineRemoveComplete(source_coords, target_coords, line_index) {\n\n        // update data\n        //this.state[source_coords[1]].columns[source_coords[0]].join.splice(line_index, 1);\n\n        // update blocks\n        var source = this.blocks[source_coords[1]].columns[source_coords[0]];\n\n        // delete line\n        source.lines.splice(line_index, 1);\n\n        // if source block has no more lines then setAsNotConnected\n        if (source.lines.length === 0) {\n\n            // if  block has no parent connections\n            if (!this.doesNodeHaveConnectedParents(source_coords[0], source_coords[1])) {\n                this.setAsNotConnectedBlock([source_coords[0], source_coords[1]]);\n            }\n        }\n\n        // external handler\n        if (!_.isUndefined(this.onLineRemove)) {\n            this.onLineRemove(this.getExternalLineEventHandlerData(source_coords, target_coords, line_index));\n        }\n\n        // TODO: emit event\n        if (!_.isUndefined(this.onNodeConnectionChangeCallback)) {\n            let _params = {\n                source_row_index: source_coords[1],\n                source_col_index: source_coords[0],\n                target_row_index: target_coords[1],\n                target_col_index: target_coords[0],\n                is_connected: false\n            };\n            this.onNodeConnectionChangeCallback(_params);\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onLineDrawComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineDrawComplete(source_coords, target_coords) {\n\n        var is_block_waiting_for_connection = false;\n\n        _.forEach(this.blocks_waiting_for_connection, (block, index) => {\n            if (_.isEqual(block, target_coords)) {\n                is_block_waiting_for_connection = true;\n                this.blocks_waiting_for_connection.splice(index, 1);\n                return false;\n            }\n        });\n\n        if (is_block_waiting_for_connection) {\n\n            // connect block\n            this.setAsConnectedBlock(target_coords);\n        }\n\n        this.$s.$apply();\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // utils\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // data for external event handlers\n    //-----------------------------\n\n    /**\n     * getExternalNodeEventHandlerData\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {{node: *, data: null}}\n     */\n    getExternalNodeEventHandlerData(col_index, row_index) {\n\n        var data_clone = _.clone(this.state[row_index].columns[col_index]);\n        var node_clone = _.clone(this.blocks[row_index].columns[col_index]);\n        var result = {\n            node: node_clone,\n            data: null\n        };\n        if (!_.isUndefined(data_clone)) {\n            result.data = data_clone;\n        }\n        return result;\n    }\n\n    /**\n     * getExternalLineEventHandlerData\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     * @returns {{node: *, data: null}}\n     */\n    getExternalLineEventHandlerData(source_coords, target_coords, line_index) {\n\n        var source_data = this.getExternalNodeEventHandlerData(source_coords[0], source_coords[1]);\n        var target_data = this.getExternalNodeEventHandlerData(target_coords[0], target_coords[1]);\n\n        return {\n            source_node: source_data.node,\n            source_data: source_data.data,\n            target_node: target_data.node,\n            target_data: target_data.data,\n            line_index: line_index\n        };\n    }\n\n    //-----------------------------\n    // active check\n    //-----------------------------\n\n    /**\n     * checkActive\n     */\n    checkActive() {\n\n        if (this.blocks.length === 0) {\n            return false;\n        }\n\n        _.forEach(this.blocks[0].columns, (col, col_index) => {\n            if (col.lines.length > 0) {\n                this.activateBlock(col_index, 0);\n            }\n        });\n    }\n\n    /**\n     * activateBlock\n     *\n     * @param col_index\n     * @param row_index\n     */\n    activateBlock(col_index, row_index) {\n\n        var block = this.blocks[row_index].columns[col_index];\n        block.active = true;\n\n        if (block.lines.length > 0) {\n\n            _.forEach(block.lines, (line) => {\n\n                // activate line\n                line.active = true;\n\n                // activate target block\n                this.activateBlock(line.to[0], line.to[1]);\n            });\n        }\n    }\n\n    /**\n     * deactivateBlock\n     *\n     * @param col_index\n     * @param row_index\n     */\n    deactivateBlock(col_index, row_index) {\n\n        var block = this.blocks[row_index].columns[col_index];\n        block.active = false;\n\n        if (block.lines.length > 0) {\n            _.forEach(block.lines, (line) => {\n\n                // deactivate line\n                line.active = false;\n\n                var does_parent_have_active_nodes = this.doesNodeHaveActiveParents(line.to[0], line.to[1]);\n\n                // deactivate target block if no active parents\n                if (!does_parent_have_active_nodes) {\n                    this.deactivateBlock(line.to[0], line.to[1]);\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // node potential\n    //-----------------------------\n\n    /**\n     * doesNodeHaveActiveParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveActiveParents(col_index, row_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        var result = false;\n        var parent_row_index = row_index - 1;\n        var parents = this.blocks[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n            _.forEach(parent.lines, (line) => {\n\n                // if parent coords are not equal to exclude coords\n                // ... and parent has a line to this block\n                // ... and parent is active\n                if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && _.isEqual(line.to, [col_index, row_index]) && parent.active) {\n                    result = true;\n                }\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * doesNodeHaveConnectedParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveConnectedParents(col_index, row_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        if (_.isUndefined(exclude_coords)) {\n            exclude_coords = [];\n        }\n\n        var result = false;\n        var parent_row_index = row_index - 1;\n        var parents = this.blocks[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n\n            // if parent coords are not equal to exclude coords and parent is potential (potential parent node is always connected)\n            if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && this.isNodePotential([col_index, row_index], [parent_col_index, parent_row_index])) {\n\n                result = true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * isNodePotential\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    isNodePotential(source_coords, target_coords) {\n\n        // if not ready\n        if (_.isUndefined(this.blocks[target_coords[1]])) {\n            return false;\n        }\n        if (_.isUndefined(this.blocks[target_coords[1]].columns[target_coords[0]])) {\n            return false;\n        }\n\n        // refuse if control\n        if (this.blocks[target_coords[1]].columns[target_coords[0]].control) {\n            return false;\n        }\n\n        // refuse if same row\n        if (source_coords[1] === target_coords[1]) {\n            return false;\n        }\n\n        // refuse if spanning more than 1 rows\n        if (Math.abs(source_coords[1] - target_coords[1]) > 1) {\n            return false;\n        }\n\n        // target row index out of bounds check\n        if (target_coords[1] >= this.blocks.length) {\n            return false;\n        }\n\n        // target col index out of bounds check\n        if (target_coords[0] >= this.blocks[target_coords[1]].columns.length) {\n            return false;\n        }\n\n        // check if target is parent or child\n        var is_target_parent = target_coords[1] < source_coords[1];\n        var source = this.blocks[source_coords[1]].columns[source_coords[0]];\n        var target = this.blocks[target_coords[1]].columns[target_coords[0]];\n        var result;\n\n        // if target is parent, then check if target has connected lines to source\n        if (is_target_parent) {\n\n            result = false;\n\n            // check that last exit was not bottom\n            if (this.source_exit_side === 'bottom') {\n                return false;\n            }\n\n            // check if target has an connected line from it source\n            _.forEach(target.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, source_coords)) {\n                    result = true;\n                    return false;\n                }\n            });\n        }\n\n        // if target is child, then\n        else {\n\n            result = true;\n\n            // check that last exit was not top\n            if (this.source_exit_side === 'top') {\n                return false;\n            }\n\n            // check if source does not have an connected line to it\n            _.forEach(source.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, target_coords)) {\n                    result = false;\n                    return false;\n                }\n            });\n        }\n\n        return result;\n    }\n\n    //-----------------------------\n    // node classes\n    //-----------------------------\n\n    /**\n     * setLineClass\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param key\n     * @param value\n     */\n    setLineClass(source_coords, target_coords, key, value) {\n\n        // loop child row columns\n        _.forEach(this.blocks[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            // if child node is potential then update class property\n            if (_.isEqual(line.to, target_coords)) {\n                line[key] = value;\n            }\n        });\n    }\n\n    /**\n     * setNodeClass\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setNodeClass(col_index, row_index, key, value) {\n        if (_.has(this.blocks[row_index].columns[col_index], key)) {\n            this.blocks[row_index].columns[col_index][key] = value;\n        }\n    }\n\n    /**\n     * setPotentialNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialNodeClasses(col_index, row_index, key, value) {\n\n        this.setPotentialChildNodeClasses(col_index, row_index, key, value);\n        this.setPotentialParentNodeClasses(col_index, row_index, key, value);\n    }\n\n    /**\n     * setPotentialChildNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialChildNodeClasses(col_index, row_index, key, value) {\n\n        // if child row is not out of bounds\n        if ((row_index + 1) < (this.blocks.length)) {\n\n            // loop child row columns\n            _.forEach(this.blocks[row_index + 1].columns, (child_col, child_col_index) => {\n\n                // if child node is potential then update class property\n                if (this.isNodePotential([col_index, row_index], [child_col_index, row_index + 1])) {\n                    child_col[key] = value;\n                }\n            });\n        }\n    }\n\n    /**\n     * setPotentialParentNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialParentNodeClasses(col_index, row_index, key, value) {\n\n        if (row_index > 0) {\n\n            // loop parent node columns\n            _.forEach(this.blocks[row_index - 1].columns, (parent_col, parent_col_index) => {\n\n                // if parent node is potential then update class property\n                if (this.isNodePotential([col_index, row_index], [parent_col_index, row_index - 1])) {\n                    parent_col[key] = value;\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // viewport\n    //-----------------------------\n\n    /**\n     * setViewport\n     *\n     * @param cols\n     * @param rows\n     */\n    setViewport(cols, rows) {\n\n        var total_item_width = this.config.block_width + this.config.col_spacing;\n        var total_item_height = this.config.block_height + this.config.row_spacing;\n\n        this.viewport_width = total_item_width * cols;\n        this.viewport_height = total_item_height * rows;\n\n        this.viewport_style = {\n            'background-color': \"#ccc\",\n            'min-width': this.viewport_width + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.wrapper_style = {\n            'max-width': (this.viewport_width + this.config.max_viewport_width_increase) + \"px\",\n            'min-width': this.viewport_width + \"px\",\n            'max-height': (this.viewport_height + (this.config.max_viewport_height_increase * rows)) + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.viewport_viewbox = \" 0 0 \" + this.viewport_width + \" \" + this.viewport_height;\n    }\n\n    /**\n     * checkViewport\n     *\n     * @param col_index\n     * @param row_index\n     */\n    checkViewport(col_index, row_index) {\n\n        var should_update_viewport = false;\n\n        // row bounds check\n        if (row_index >= this.grid_row_count) {\n\n            // increase rowspan\n            this.grid_row_count++;\n            should_update_viewport = true;\n        }\n\n        // col bounds check\n        if (col_index >= this.grid_col_count) {\n\n            // increase colspan\n            this.grid_col_count++;\n            should_update_viewport = true;\n\n            // add bg grid col\n            this.addBgGridCol(this.grid_col_count - 1);\n        }\n\n        // set viewport\n        if (should_update_viewport) {\n            this.setViewport(this.grid_col_count, this.grid_row_count);\n        }\n    }\n\n    //-----------------------------\n    // coords\n    //-----------------------------\n\n    /**\n     * calculateColX\n     *\n     * @param index\n     */\n    calculateColX(index) {\n        if (index === 0) {\n            return 0;\n        }\n        var first_col_width = this.config.block_width + (this.config.col_spacing / 2);\n        var col_width = this.config.block_width + (this.config.col_spacing);\n        return first_col_width + ((index - 1) * col_width);\n    }\n\n    /**\n     * calculateColWidth\n     *\n     * @param index\n     */\n    calculateColWidth(index) {\n        var total_item_width = index === 0 ? this.config.block_width + (this.config.col_spacing / 2) : this.config.block_width + this.config.col_spacing;\n        return total_item_width;\n    }\n\n    /**\n     * calculateRowY\n     *\n     * @param index\n     */\n    calculateRowY(index) {\n        var row_height = this.config.block_height + this.config.row_spacing;\n        return index * row_height;\n    }\n\n    /**\n     * calculateRowHeight\n     *\n     * @param index\n     */\n    calculateRowHeight() {\n        return this.config.block_height + this.config.row_spacing;\n    }\n\n    //-----------------------------\n    // drawing\n    //-----------------------------\n\n    /**\n     * addLine\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    addLine(source_coords, target_coords, connected) {\n\n        // check bounds\n        if (target_coords[1] >= this.blocks.length) {\n            return false;\n        }\n\n        // get coords\n        var source_lock_coords = Utils.getCoords(source_coords[0], source_coords[1], BLOCK_BOTTOM, this.config);\n        var target_lock_coords = Utils.getCoords(target_coords[0], target_coords[1], BLOCK_TOP, this.config);\n\n        // add line properties\n        this.blocks[source_coords[1]].columns[source_coords[0]].lines.push({\n            connected: !_.isUndefined(connected) ? connected : false,\n            from: source_coords,\n            to: target_coords,\n            x1: source_lock_coords[0],\n            y1: source_lock_coords[1],\n            x2: target_lock_coords[0],\n            y2: target_lock_coords[1]\n        });\n\n        if (connected) {\n            // update data\n            // this.state[source_coords[1]].columns[source_coords[0]].join.push(target_coords[0]);\n        }\n    }\n\n    /**\n     * updateLineTarget\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    updateLineTarget(source_coords, target_coords) {\n\n        // get target lock coords\n        var target_lock_coords = Utils.getCoords(target_coords[0], target_coords[1], BLOCK_TOP, this.config);\n\n        // find line\n        _.forEach(this.blocks[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.to = target_coords;\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeLine\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    removeLine(source_coords, target_coords) {\n\n        // get target lock coords\n        var target_lock_coords = Utils.getCoords(source_coords[0], source_coords[1], BLOCK_BOTTOM, this.config);\n\n        // find line\n        _.forEach(this.blocks[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                var block = this.blocks[target_coords[1]].columns[target_coords[0]];\n                var block_has_connected_parents = this.doesNodeHaveConnectedParents(target_coords[0], target_coords[1], source_coords);\n\n                // if block has no lines & has no parent connections\n                if (block.lines.length === 0 && !block_has_connected_parents) {\n                    // set as not connected\n                    this.setAsNotConnectedBlock(target_coords);\n                }\n\n                // if block has no parent connections\n                var block_has_active_parents = this.doesNodeHaveActiveParents(target_coords[0], target_coords[1], source_coords);\n\n                if (!block_has_active_parents) {\n\n                    // deactivate block\n                    this.deactivateBlock(target_coords[0], target_coords[1]);\n                }\n\n                // set line properties\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.previous_to = line.to; // TODO: this feels a bit hacky\n                line.to = [source_coords[0], source_coords[1]];\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeUnconnectedLines\n     *\n     * @param selection\n     */\n    removeUnconnectedLines(selection) {\n\n        _.forEach(this.blocks[selection[0][1]].columns[selection[0][0]].lines, (line) => {\n            if (!line.connected) {\n                this.removeLine(this.selection[0], this.selection[1]);\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedLines\n     *\n     * @param selection\n     */\n    setAsConnectedLines(selection) {\n\n        _.forEach(this.blocks[selection[0][1]].columns[selection[0][0]].lines, (line, line_index) => {\n            if (!line.connected) {\n\n                // setAsConnected line\n                line.connected = true;\n\n                // setAsConnected blocks\n                this.setAsConnectedBlock(line.from);\n                this.setAsConnectedBlock(line.to);\n\n                // update data\n                // TODO: emit event\n                if (!_.isUndefined(this.onNodeConnectionChangeCallback)) {\n                    let _params = {\n                        source_row_index: line.from[1],\n                        source_col_index: line.from[0],\n                        target_row_index: line.to[1],\n                        target_col_index: line.to[0],\n                        is_connected: true\n                    };\n                    this.onNodeConnectionChangeCallback(_params);\n                }\n                // this.state[line.from[1]].columns[line.from[0]].join.splice(line_index, 0, line.to[0]);\n\n                // external handler\n                if (!_.isUndefined(this.onLineAdd)) {\n                    this.onLineAdd(this.getExternalLineEventHandlerData(line.from, line.to, line_index));\n                }\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedBlock\n     *\n     * @param coords\n     */\n    setAsConnectedBlock(coords) {\n        this.blocks[coords[1]].columns[coords[0]].connected = true;\n    }\n\n    /**\n     * setAsNotConnectedBlock\n     *\n     * @param coords\n     */\n    setAsNotConnectedBlock(coords) {\n        this.blocks[coords[1]].columns[coords[0]].connected = false;\n    }\n\n    /**\n     * addBlock\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     * @param lines\n     * @returns {boolean}\n     */\n    addBlock(col_index, row_index, label, lines) {\n\n        if (row_index > this.blocks.length) {\n            throw new Error(\"Invalid row index\");\n        }\n\n        // create row if it doesn't exist\n        if (row_index === this.blocks.length) {\n            this.blocks.push({columns: []});\n        }\n\n        // if block already exists (control) then remove and re-add after block\n        var removed_block;\n\n        if (!_.isUndefined(this.blocks[row_index].columns[col_index])) {\n            removed_block = this.blocks[row_index].columns.splice(col_index, 1);\n        }\n\n        // get top left coords\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT, this.config);\n\n        // lines\n        var block_lines = [];\n        var line_source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_BOTTOM, this.config);\n\n        _.forEach(lines, (line_target_col_index) => {\n\n            var line_target_coords = [line_target_col_index, row_index + 1];\n            var line_target_lock_coords = Utils.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP, this.config);\n\n            block_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set blocks as connected\n            this.blocks_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set block properties\n        var block = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: label,\n            connected: block_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: block_lines\n        };\n\n        // add block\n        this.blocks[row_index].columns.push(block);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n        // replace removed block\n        if (!_.isUndefined(removed_block)) {\n            this.addControl(removed_block[0].row_index);\n        }\n\n        // TODO: emit event\n        if (!_.isUndefined(this.onNodeAddedCallback)) {\n            this.onNodeAddedCallback({ row_index, col_index });\n        }\n    }\n\n    /**\n     * updateBlock\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     */\n    updateBlock(col_index, row_index, label) {\n\n        // update label\n        if (!_.isUndefined(label) && this.blocks[row_index].columns[col_index].label !== label) {\n            this.blocks[row_index].columns[col_index].label = label;\n        }\n\n        // // update lines\n        // if (!_.isUndefined(lines)) {\n        //\n        //     var line_source_lock_coords     = Utils.getCoords(col_index, row_index, BLOCK_BOTTOM, this.config);\n        //\n        //     _.forEach(lines, (line_target_col_index) => {\n        //\n        //         var line_target_coords = [line_target_col_index, row_index + 1];\n        //         var line_target_lock_coords     = Utils.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP, this.config);\n        //\n        //         this.blocks[row_index].columns[col_index].lines.push({\n        //             connected: true,\n        //             from: [col_index, row_index],\n        //             to: line_target_coords,\n        //             x1: line_source_lock_coords[0],\n        //             y1: line_source_lock_coords[1],\n        //             x2: line_target_lock_coords[0],\n        //             y2: line_target_lock_coords[1]\n        //         });\n        //\n        //         this.setNodeClass(col_index, row_index, 'connected', true);\n        //\n        //         // set blocks as connected\n        //         this.blocks_waiting_for_connection.push(line_target_coords);\n        //     });\n        // }\n    }\n\n    /**\n     * removeBlock\n     *\n     * @param col_index\n     * @param row_index\n     */\n    removeBlock(col_index, row_index) {\n\n        if (row_index >= this.blocks.length) {\n            return true;\n        }\n\n        if (col_index >= this.blocks[row_index].columns.length - 1) {\n            return true;\n        }\n\n        // remove lines\n        _.forEach(this.blocks[row_index].columns[col_index].lines, (line) => {\n            this.removeLine(line.from, line.to);\n        });\n\n        // remove block\n        this.blocks[row_index].columns.splice(col_index, 1);\n\n        // update data\n        // this.state[row_index].columns.splice(col_index, 1);\n\n        // update siblings\n        for (var i = col_index; i < (this.blocks[row_index].columns.length); i++) {\n            this.updateBlockAfterSiblingAddedOrRemoved(i, row_index);\n\n            // if not last column (control)\n            if (i < this.blocks[row_index].columns.length - 1) {\n                // TODO: why not update blocks???\n                // this.state[row_index].columns[i].data.ui_column_index = i;\n                // this.state[row_index].columns[i].data.ui_row_index = row_index;\n            }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            var parent_row_index = row_index - 1;\n            _.forEach(this.blocks[parent_row_index].columns, (column, parent_col_index) => {\n                _.forEach(column.lines, (line, line_index) => {\n\n                    // if parent connects to this node\n                    if (_.isEqual(line.to, [col_index, row_index])) {\n                        column.lines.splice(line_index, 1);\n\n                        // update data\n                        //this.state[parent_row_index].columns[parent_col_index].join.splice(line_index, 1);\n\n                        // if parent no longer has any lines\n                        if (column.lines.length === 0) {\n                            this.setAsNotConnectedBlock([parent_col_index, parent_row_index]);\n                        }\n                    }\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] > col_index) {\n\n                        // update lines target\n                        var new_line_to = [line.to[0] - 1, line.to[1]];\n\n                        // get target lock coords\n                        var target_lock_coords = Utils.getCoords(new_line_to[0], new_line_to[1], BLOCK_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n        }\n\n        // update children\n        // TODO: can we use block???\n        if (row_index !== this.blocks.length - 1) {\n            var children_row_index = row_index + 1;\n            _.forEach(this.blocks[children_row_index].columns, (column, children_col_index) => {\n\n                // if  block has no parent connections\n                if (!this.doesNodeHaveConnectedParents(children_col_index, children_row_index)) {\n                    this.setAsNotConnectedBlock([children_col_index, children_row_index]);\n                }\n            });\n        }\n    }\n\n    /**\n     * insertBlock\n     *\n     * @param col_index\n     * @param row_index\n     * @param data\n     */\n    insertBlock(col_index, row_index, data) {\n\n        if (row_index >= this.blocks.length) {\n            return true;\n        }\n\n        if (col_index > this.blocks[row_index].columns.length - 1) {\n            return true;\n        }\n\n        // get top left coords\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT, this.config);\n\n        // lines\n        var block_lines = [];\n        var line_source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_BOTTOM, this.config);\n\n        _.forEach(data.join, (line_target_col_index) => {\n\n            var line_target_coords = [line_target_col_index, row_index + 1];\n            var line_target_lock_coords = Utils.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP, this.config);\n\n            block_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set blocks as connected\n            this.blocks_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set block properties\n        var block = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: data.label,\n            connected: block_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: block_lines\n        };\n\n        // insert block\n        this.blocks[row_index].columns.splice(col_index, 0, block);\n\n        // update data\n        //this.state[row_index].columns.splice(col_index, 0, data);\n\n        // update siblings\n        for (var i = col_index + 1; i < (this.blocks[row_index].columns.length); i++) {\n\n            this.updateBlockAfterSiblingAddedOrRemoved(i, row_index);\n\n            // if not last column (control)\n            // if (i < this.blocks[row_index].columns.length - 1) {\n            //     this.state[row_index].columns[i].data.ui_column_index = i;\n            //     this.state[row_index].columns[i].data.ui_row_index = row_index;\n            // }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            var parent_row_index = row_index - 1;\n            _.forEach(this.blocks[parent_row_index].columns, (column) => {\n                _.forEach(column.lines, (line) => {\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] >= col_index) {\n\n                        // update lines target\n                        var new_line_to = [line.to[0] + 1, line.to[1]];\n\n                        // get target lock coords\n                        var target_lock_coords = Utils.getCoords(new_line_to[0], new_line_to[1], BLOCK_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * updateBlockAfterSiblingAddedOrRemoved\n     *\n     * @param {Integer}    col_index\n     * @param {Integer}    row_index\n     */\n    updateBlockAfterSiblingAddedOrRemoved(col_index, row_index) {\n\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT, this.config);\n        var center_coords = Utils.getCoords(col_index, row_index, BLOCK_CENTER, this.config);\n\n        // update block\n\n        this.blocks[row_index].columns[col_index].col_index = col_index;\n        this.blocks[row_index].columns[col_index].coords = top_left_coords;\n        this.blocks[row_index].columns[col_index].x = top_left_coords[0];\n        this.blocks[row_index].columns[col_index].y = top_left_coords[1];\n\n        // update labels\n        // last block has different label position\n        if (col_index === (this.blocks[row_index].columns.length - 1)) {\n            this.blocks[row_index].columns[col_index].label_x = center_coords[0];\n            this.blocks[row_index].columns[col_index].label_y = center_coords[1];\n        } else {\n            this.blocks[row_index].columns[col_index].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.blocks[row_index].columns[col_index].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.blocks[row_index].columns[col_index].lines, (line) => {\n\n            // get target lock coords\n            var source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * updateBlockAfterChildAddedOrRemoved\n     *\n     * @param {Integer}    col_index\n     * @param {Integer}    row_index\n     */\n    updateBlockAfterChildAddedOrRemoved(col_index, row_index) {\n\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT, this.config);\n        var center_coords = Utils.getCoords(col_index, row_index, BLOCK_CENTER, this.config);\n\n        // update block\n\n        this.blocks[row_index].columns[col_index].col_index = col_index;\n        this.blocks[row_index].columns[col_index].coords = top_left_coords;\n        this.blocks[row_index].columns[col_index].x = top_left_coords[0];\n        this.blocks[row_index].columns[col_index].y = top_left_coords[1];\n\n        // update labels\n        // last block has different label position\n        if (col_index === (this.blocks[row_index].columns.length - 1)) {\n            this.blocks[row_index].columns[col_index].label_x = center_coords[0];\n            this.blocks[row_index].columns[col_index].label_y = center_coords[1];\n        } else {\n            this.blocks[row_index].columns[col_index].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.blocks[row_index].columns[col_index].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.blocks[row_index].columns[col_index].lines, (line) => {\n\n            // get target lock coords\n            var source_lock_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * addControl\n     *\n     * @param {Integer}    row_index\n     */\n    addControl(row_index) {\n\n        // create row if it doesn't exist\n        if (row_index === this.blocks.length) {\n            this.blocks.push({columns: []});\n        }\n\n        // validate row index\n        if (row_index >= this.blocks.length) {\n            throw new Error(\"Invalid row index\");\n        }\n\n        var col_index = this.blocks[row_index].columns.length;\n\n        // get top left coords\n        var top_left_coords = Utils.getCoords(col_index, row_index, BLOCK_TOP_LEFT, this.config);\n        var center_coords = Utils.getCoords(col_index, row_index, BLOCK_CENTER, this.config);\n\n        // set block properties\n        var block = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: center_coords[0],\n            label_y: center_coords[1],\n            label: \"+\",\n            connected: false,\n            control: true,\n            row_index: row_index,\n            col_index: col_index,\n            lines: []\n        };\n\n        // add block\n        this.blocks[row_index].columns.push(block);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n    }\n\n    /**\n     * addBgGridCol\n     *\n     * @param {Integer}    index\n     */\n    addBgGridCol(index) {\n\n        this.bg_col_grid.push({\n            index: index,\n            x: this.calculateColX(index),\n            width: this.calculateColWidth(index)\n        });\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // update\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * update\n     *\n     * @param data\n     * @param column_property_name\n     */\n    update(data, column_property_name) {\n\n        // add controls\n        _.forEach(data, (row, row_index) => {\n\n            // ... if row index exceeds or equals current UI rows\n            if (row_index >= this.blocks.length) {\n                this.addControl(row_index);\n            }\n        });\n\n        // add blocks\n        _.forEach(data, (row, row_index) => {\n            _.forEach(row[column_property_name], (col, col_index) => {\n\n                // update block\n                this.updateBlock(col_index, row_index, col.label);\n\n                // ... if column index exceeds or equals current UI cols (excluding control)\n                if (col_index >= this.blocks[row_index].columns.length - 1) {\n                    var label = _.has(col, 'label') ? col.label : \"\";\n                    var lines = _.has(col, 'join') ? col.join : [];\n                    this.addBlock(col_index, row_index, label, lines);\n                }\n            });\n        });\n\n        // set viewport\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        // check active\n        this.checkActive();\n    }\n}\n\nAngularSvgNodesController.$inject = [ '$scope' ];"],"sourceRoot":"src/app/*.js"}