{"version":3,"sources":["angular-svg-nodes-controller.js"],"names":[],"mappings":"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","file":"angular-svg-nodes-controller.js","sourcesContent":["\nexport default class AngularSvgNodesController {\n\n    constructor($s,\n                BLOCK_TOP_LEFT,\n                BLOCK_TOP,\n                BLOCK_CENTER,\n                BLOCK_BOTTOM,\n                ACTION_ADD,\n                ACTION_REMOVE,\n                ACTION_UPDATE,\n                INITIAL_GRID_COLS,\n                INITIAL_GRID_ROWS,\n                BLOCK_WIDTH,\n                BLOCK_HEIGHT,\n                COL_SPACING,\n                ROW_SPACING,\n                LABEL_SPACING,\n                DISABLE_CONTROL_NODES,\n                MAX_VIEWPORT_WIDTH_INCREASE,\n                MAX_VIEWPORT_HEIGHT_INCREASE) {\n\n        var self = this;\n\n        ////////////////////////////////////////////////\n        //\n        // vars\n        //\n        ////////////////////////////////////////////////\n\n        //-----------------------------\n        // api\n        //-----------------------------\n\n        this.api = $s.api || {};\n\n        //-----------------------------\n        // control\n        //-----------------------------\n\n        var initialized = false;\n\n        // an array of block coords that will be set as connected on teh line\n        this.blocks_waiting_for_connection = [];\n\n        // parent coordinates (for reference)\n        this.parent_coords = [];\n\n        // view coordinates (for reference)\n        this.coords = [];\n\n        // view element data\n        this.blocks = [];\n\n        // array for bg grid\n        this.bg_col_grid = [];\n        this.bg_col_grid_hover_index = null;\n\n        // grid dimmensions\n        this.block_width = BLOCK_WIDTH;\n        this.block_height = BLOCK_HEIGHT;\n        this.col_spacing = COL_SPACING;\n        this.row_spacing = ROW_SPACING;\n        this.grid_col_count = INITIAL_GRID_COLS;\n        this.grid_row_count = INITIAL_GRID_ROWS;\n        this.label_width = BLOCK_WIDTH - (LABEL_SPACING * 2);\n        this.label_height = BLOCK_HEIGHT - (LABEL_SPACING * 2);\n\n        // viewport style & bounds\n        this.wrapper_style = \"\";\n        this.viewport_style = \"\";\n        this.viewport_width = 0;\n        this.viewport_height = 0;\n        this.viewport_viewbox = \"\";\n\n        // node selections\n        this.selection = [];\n        this.source_exit_side = null;\n\n        // active node\n        this.selected_node = [];\n\n        ////////////////////////////////////////////////\n        //\n        // handlers\n        //\n        ////////////////////////////////////////////////\n\n        //-----------------------------\n        // general\n        //-----------------------------\n\n        /**\n         * onNodeSelect\n         *\n         * @param col_index\n         * @param row_index\n         * @returns {boolean}\n         */\n        this.onNodeSelect = function (col_index, row_index) {\n\n            // external handler\n            if (!_.isUndefined($s.onNodeMouseDown)) {\n                $s.onNodeMouseDown(self.getExternalNodeEventHandlerData(col_index, row_index));\n            }\n\n            // if control\n            if (self.blocks[row_index].columns[col_index].control) {\n                if (!DISABLE_CONTROL_NODES) {\n                    this.onControlNodeSelect(col_index, row_index);\n                }\n                return true;\n            }\n\n            // if block\n            this.onBlockNodeSelect(col_index, row_index);\n        };\n\n        /**\n         * onNodeDeselect\n         *\n         * @param col_index\n         * @param row_index\n         * @returns {boolean}\n         */\n        this.onNodeDeselect = function (col_index, row_index) {\n\n            // external handler\n            if (!_.isUndefined($s.onNodeMouseUp)) {\n                $s.onNodeMouseUp(self.getExternalNodeEventHandlerData(col_index, row_index));\n            }\n\n            // if control\n            if (self.blocks[row_index].columns[col_index].control) {\n                return false;\n            }\n\n            // if block\n            this.onBlockNodeDeselect(col_index, row_index);\n        };\n\n        /**\n         * onNodeMouseOver\n         *\n         * @param col_index\n         * @param row_index\n         * @returns {boolean}\n         */\n        this.onNodeMouseOver = function (col_index, row_index) {\n\n            // if control\n            if (self.blocks[row_index].columns[col_index].control) {\n                self.onControlNodeMouseOver(col_index, row_index);\n                return true;\n            }\n\n            // if block\n            self.onBlockNodeMouseOver(col_index, row_index);\n        };\n\n        /**\n         * onNodeMouseOut\n         *\n         * @param col_index\n         * @param row_index\n         * @param exit_side\n         * @returns {boolean}\n         */\n        this.onNodeMouseOut = function (col_index, row_index, exit_side) {\n\n            // if control\n            if (self.blocks[row_index].columns[col_index].control) {\n                self.onControlNodeMouseOut(col_index, row_index);\n                return true;\n            }\n\n            // if block\n            self.onBlockNodeMouseOut(col_index, row_index, exit_side);\n        };\n\n        //-------------------------------------------------\n        // control node handlers\n        //-------------------------------------------------\n\n        /**\n         * onControlNodeSelect\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.onControlNodeSelect = function (col_index, row_index) {\n\n            self.addBlock(col_index, row_index, \"NEW\", []);\n\n            $s.$apply();\n        };\n\n        /**\n         * onControlNodeMouseOver\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.onControlNodeMouseOver = function (col_index, row_index) {\n\n            // disallow if selection\n            if (self.selection.length > 0) {\n                return false;\n            }\n\n            // styles\n            self.setNodeClass(col_index, row_index, 'control_hover', true);\n\n            $s.$apply();\n        };\n\n        /**\n         * onControlNodeMouseOut\n         *\n         * @param col_index\n         * @param row_index\n         * @returns {boolean}\n         */\n        this.onControlNodeMouseOut = function (col_index, row_index) {\n\n            // disallow if selection\n            if (self.selection.length > 0) {\n                return false;\n            }\n\n            // styles\n            self.setNodeClass(col_index, row_index, 'control_hover', false);\n\n            $s.$apply();\n        };\n\n        //-------------------------------------------------\n        // block node handlers\n        //-------------------------------------------------\n\n        /**\n         * onBlockNodeSelect\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.onBlockNodeSelect = function (col_index, row_index) {\n\n            //-------------------------\n            // styles\n            //-------------------------\n\n            self.setNodeClass(col_index, row_index, 'source_hover', false);\n            self.setNodeClass(col_index, row_index, 'source', true);\n            self.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', false);\n            self.setPotentialNodeClasses(col_index, row_index, 'potential_target', true);\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // set selection\n            self.selection = [[col_index, row_index]];\n            self.selected_node = [col_index, row_index];\n\n            $s.$apply();\n        };\n\n        /**\n         * onBlockNodeDeselect\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.onBlockNodeDeselect = function (col_index, row_index) {\n\n            // reset last exit side\n            self.source_exit_side = null;\n\n            //-------------------------\n            // styles\n            //-------------------------\n\n            // if one selection\n            if (self.selection.length === 1) {\n\n                // if deselecting on current source\n                if (_.isEqual(self.selection[0], [col_index, row_index])) {\n\n                    self.setNodeClass(col_index, row_index, 'source', false);\n                    self.setNodeClass(col_index, row_index, 'source_hover', true);\n                    self.setPotentialNodeClasses(col_index, row_index, 'potential_target', false);\n                    self.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', true);\n                }\n            }\n\n            // if two selections\n            else if (self.selection.length === 2) {\n\n                // if deselecting on current target (& is potential ?)\n                if (_.isEqual(self.selection[1], [col_index, row_index])) {\n\n                    self.setNodeClass(col_index, row_index, 'target', false);\n\n                    // if  block has no parent connections\n                    if (!self.doesNodeHaveConnectedParents(col_index, row_index)) {\n                        self.setPotentialNodeClasses(col_index, row_index, 'potential_target', false);\n                    }\n\n                    // check active\n                    self.checkActive();\n                }\n            }\n\n            //-------------------------\n            // line updates\n            //-------------------------\n\n            // if 2 selections\n            if (self.selection.length === 2) {\n\n                // if deselecting on current target & is potential\n                if (_.isEqual(self.selection[1], [col_index, row_index]) && self.isNodePotential(self.selection[0], [col_index, row_index])) {\n\n                    var is_target_parent = self.selection[0][1] > row_index;\n\n                    // if target is parent then remove line\n                    if (is_target_parent) {\n                        self.removeLine(self.selection[1], self.selection[0]);\n                    }\n\n                    // if target is child then setAsConnected line\n                    else {\n                        self.setAsConnectedLines(self.selection, \"A\");\n\n                        // check active\n                        self.checkActive();\n                    }\n                }\n            }\n        };\n\n        /**\n         * onBlockNodeMouseOver\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.onBlockNodeMouseOver = function (col_index, row_index) {\n\n            //-------------------------\n            // styles\n            //-------------------------\n\n            // if no selection\n            if (self.selection.length === 0) {\n\n                self.setNodeClass(col_index, row_index, 'source_hover', true);\n                self.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', true);\n            }\n\n            // if two selections\n            if (self.selection.length === 2) {\n\n                // if potential\n                if (self.isNodePotential(self.selection[0], [col_index, row_index])) {\n\n                    self.setNodeClass(col_index, row_index, 'potential_target', false);\n                    self.setNodeClass(col_index, row_index, 'target', true);\n                    self.setLineClass(self.selection[0], [col_index, row_index], 'target', true);\n                }\n            }\n\n            // if col changed\n            if (self.bg_col_grid_hover_index !== col_index) {\n\n                //self.bg_col_grid_hover_index = col_index;\n\n                //-------------------------\n                // selection updates\n                //-------------------------\n\n                // if 2 selections and new col index is potential\n                //if (self.selection.length === 2 && self.isNodePotential(self.selection[0], [col_index, self.selection[1][1]])) {\n                //    self.selection[1][0] = col_index;\n                //}\n            }\n\n            $s.$apply();\n        };\n\n        /**\n         * onBlockNodeMouseOut\n         *\n         * @param col_index\n         * @param row_index\n         * @param exit_side\n         * @returns {boolean}\n         */\n        this.onBlockNodeMouseOut = function (col_index, row_index, exit_side) {\n\n            //-------------------------\n            // styles\n            //-------------------------\n\n            // if no selections\n            if (self.selection.length === 0) {\n\n                self.setNodeClass(col_index, row_index, 'source_hover', false);\n                self.setPotentialNodeClasses(col_index, row_index, 'potential_target_hover', false);\n            }\n\n            // if two selections\n            else if (self.selection.length === 2) {\n\n                // if potential\n                if (self.isNodePotential(self.selection[0], [col_index, row_index])) {\n\n                    self.setNodeClass(col_index, row_index, 'target', false);\n                    self.setNodeClass(col_index, row_index, 'potential_target', true);\n                    self.setLineClass(self.selection[0], [col_index, row_index], 'target', false);\n                }\n            }\n\n            // if this is source selection & source_exit_side not yet set\n            if (_.isEqual(self.selection[0], [col_index, row_index]) && _.isNull(self.source_exit_side)) {\n\n                // if exited top\n                if (exit_side === 'top') {\n\n                    // remove 'potential child' class from potential children\n                    self.setPotentialChildNodeClasses(col_index, row_index, 'potential_target', false);\n                }\n\n                // if exited bottom\n                else if (exit_side === 'bottom') {\n\n                    // remove 'potential child' class from potential parent\n                    self.setPotentialParentNodeClasses(col_index, row_index, 'potential_target', false);\n                }\n            }\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // if one selection one selected\n            if (self.selection.length === 1) {\n\n                // if this is source selection\n                if (_.isEqual(self.selection[0], [col_index, row_index])) {\n\n                    // update source exit side\n                    self.source_exit_side = exit_side;\n                }\n\n                var target_coords;\n\n                // if exited top\n                if (exit_side === 'top') {\n\n                    target_coords = [self.bg_col_grid_hover_index, row_index - 1];\n\n                    // if target is potential\n                    if (self.isNodePotential([col_index, row_index], target_coords)) {\n                        self.selection.push(target_coords);\n                    }\n                }\n\n                // if exited bottom\n                else if (exit_side === 'bottom') {\n\n                    var target_row_index = row_index + 1;\n                    target_coords = [self.bg_col_grid_hover_index, target_row_index];\n\n                    // if not spanning more than one row && target is potential\n                    if (Math.abs(self.selection[0][1] - target_row_index) <= 1 && self.isNodePotential([col_index, row_index], target_coords)) {\n\n                        self.selection.push(target_coords);\n                    }\n\n                }\n            }\n\n            $s.$apply();\n        };\n\n        //-------------------------------------------------\n        // grid handlers\n        //-------------------------------------------------\n\n        /**\n         * onRootDeselect\n         */\n        this.onRootDeselect = function () {\n\n            // reset source_exit_side\n            self.source_exit_side = null;\n\n            // nothing to do if there are no selections\n            if (self.selection.length === 0) {\n                return true;\n            }\n\n            //-------------------------\n            // styles\n            //-------------------------\n\n            // if selections\n            if (self.selection.length > 0) {\n\n                self.setNodeClass(self.selection[0][0], self.selection[0][1], 'source', false);\n                self.setPotentialNodeClasses(self.selection[0][0], self.selection[0][1], 'target', false);\n                self.setPotentialNodeClasses(self.selection[0][0], self.selection[0][1], 'potential_target', false);\n            }\n\n            //-------------------------\n            // line updates\n            //-------------------------\n\n            // if 2 selections\n            if (self.selection.length === 2) {\n\n                // remove Unconnected lines\n                self.removeUnconnectedLines(self.selection);\n            }\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // reset if there are not 2 selections\n            if (self.selection.length > 0) {\n                self.selection = [];\n            }\n\n            $s.$apply();\n        };\n\n        /**\n         * onBgColGridMouseOver\n         */\n        this.onBgColGridMouseOver = function (index) {\n\n            // do nothing if unchanged\n            if (self.bg_col_grid_hover_index === index) {\n                return true;\n            }\n\n            self.bg_col_grid_hover_index = index;\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // if 1 selection\n            if (self.selection.length === 1) {\n\n                var target_coords = self.source_exit_side === 'top' ? [index, self.selection[0][1] - 1] : [index, self.selection[0][1] + 1];\n\n                // if target is potential\n                if (self.isNodePotential(self.selection[0], target_coords)) {\n                    self.selection.push(target_coords);\n                }\n            }\n\n            // if 2 selections and new col index is potential\n            else if (self.selection.length === 2 && self.isNodePotential(self.selection[0], [index, self.selection[1][1]])) {\n                self.selection[1][0] = index;\n            }\n\n            $s.$apply();\n        };\n\n        /**\n         * onRootMouseLeave\n         *\n         * @param e\n         */\n        this.onRootMouseLeave = function () {\n\n            //-------------------------\n            // styles\n            //-------------------------\n\n            // if 1 selection\n            if (self.selection.length === 1) {\n\n                self.setNodeClass(self.selection[0][0], self.selection[0][1], 'source', false);\n                self.setPotentialNodeClasses(self.selection[0][0], self.selection[0][1], 'potential_target', false);\n            }\n\n            // if 2 selections\n            else if (self.selection.length === 2) {\n\n                self.setNodeClass(self.selection[0][0], self.selection[0][1], 'source', false);\n                self.setNodeClass(self.selection[1][0], self.selection[1][1], 'target', false);\n                self.setPotentialNodeClasses(self.selection[0][0], self.selection[0][1], 'potential_target', false);\n            }\n\n            //-------------------------\n            // line updates\n            //-------------------------\n\n            // if 2 selections\n            if (self.selection.length === 2) {\n\n                // remove Unconnected lines\n                self.removeUnconnectedLines(self.selection);\n            }\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            self.selection = [];\n\n            $s.$apply();\n        };\n\n        //-------------------------------------------------\n        // line handlers\n        //-------------------------------------------------\n\n        /**\n         * onLineRemoveComplete\n         *\n         * @param source_coords\n         * @param target_coords\n         * @param line_index\n         */\n        this.onLineRemoveComplete = function (source_coords, target_coords, line_index) {\n\n            // update data\n            $s.rows[source_coords[1]].columns[source_coords[0]].join.splice(line_index, 1);\n\n            // update blocks\n            var source = self.blocks[source_coords[1]].columns[source_coords[0]];\n\n            // delete line\n            source.lines.splice(line_index, 1);\n\n            // if source block has no more lines then setAsNotConnected\n            if (source.lines.length === 0) {\n\n                // if  block has no parent connections\n                if (!self.doesNodeHaveConnectedParents(source_coords[0], source_coords[1])) {\n                    self.setAsNotConnectedBlock([source_coords[0], source_coords[1]]);\n                }\n            }\n\n            // external handler\n            if (!_.isUndefined($s.onLineRemove)) {\n                $s.onLineRemove(self.getExternalLineEventHandlerData(source_coords, target_coords, line_index));\n            }\n\n            $s.$apply();\n        };\n\n        /**\n         * onLineDrawComplete\n         *\n         * @param source_coords\n         * @param target_coords\n         * @param line_index\n         */\n        this.onLineDrawComplete = function (source_coords, target_coords) {\n\n            var is_block_waiting_for_connection = false;\n\n            _.forEach(self.blocks_waiting_for_connection, function (block, index) {\n                if (_.isEqual(block, target_coords)) {\n                    is_block_waiting_for_connection = true;\n                    self.blocks_waiting_for_connection.splice(index, 1);\n                    return false;\n                }\n            });\n\n            if (is_block_waiting_for_connection) {\n\n                // connect block\n                self.setAsConnectedBlock(target_coords);\n            }\n\n            $s.$apply();\n        };\n\n        ////////////////////////////////////////////////\n        //\n        // utils\n        //\n        ////////////////////////////////////////////////\n\n        //-----------------------------\n        // data for external event handlers\n        //-----------------------------\n\n        /**\n         * getExternalNodeEventHandlerData\n         *\n         * @param col_index\n         * @param row_index\n         * @returns {{node: *, data: null}}\n         */\n        this.getExternalNodeEventHandlerData = function (col_index, row_index) {\n\n            var data_clone = _.clone($s.rows[row_index].columns[col_index]);\n            var node_clone = _.clone(self.blocks[row_index].columns[col_index]);\n            var result = {\n                node: node_clone,\n                data: null\n            };\n            if (!_.isUndefined(data_clone)) {\n                result.data = data_clone;\n            }\n            return result;\n        };\n\n        /**\n         * getExternalLineEventHandlerData\n         *\n         * @param source_coords\n         * @param target_coords\n         * @param line_index\n         * @returns {{node: *, data: null}}\n         */\n        this.getExternalLineEventHandlerData = function (source_coords, target_coords, line_index) {\n\n            var source_data = self.getExternalNodeEventHandlerData(source_coords[0], source_coords[1]);\n            var target_data = self.getExternalNodeEventHandlerData(target_coords[0], target_coords[1]);\n\n            return {\n                source_node: source_data.node,\n                source_data: source_data.data,\n                target_node: target_data.node,\n                target_data: target_data.data,\n                line_index: line_index\n            };\n        };\n\n        //-----------------------------\n        // active check\n        //-----------------------------\n\n        /**\n         * checkActive\n         */\n        this.checkActive = function () {\n\n            if (self.blocks.length === 0) {\n                return false;\n            }\n\n            _.forEach(self.blocks[0].columns, function (col, col_index) {\n                if (col.lines.length > 0) {\n                    self.activateBlock(col_index, 0);\n                }\n            });\n        };\n\n        /**\n         * activateBlock\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.activateBlock = function (col_index, row_index) {\n\n            var block = self.blocks[row_index].columns[col_index];\n            block.active = true;\n\n            if (block.lines.length > 0) {\n\n                _.forEach(block.lines, function (line) {\n\n                    // activate line\n                    line.active = true;\n\n                    // activate target block\n                    self.activateBlock(line.to[0], line.to[1]);\n                });\n            }\n        };\n\n        /**\n         * deactivateBlock\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.deactivateBlock = function (col_index, row_index) {\n\n            var block = self.blocks[row_index].columns[col_index];\n            block.active = false;\n\n            if (block.lines.length > 0) {\n                _.forEach(block.lines, function (line) {\n\n                    // deactivate line\n                    line.active = false;\n\n                    var does_parent_have_active_nodes = self.doesNodeHaveActiveParents(line.to[0], line.to[1]);\n\n                    // deactivate target block if no active parents\n                    if (!does_parent_have_active_nodes) {\n                        self.deactivateBlock(line.to[0], line.to[1]);\n                    }\n                });\n            }\n        };\n\n        //-----------------------------\n        // node potential\n        //-----------------------------\n\n        /**\n         * doesNodeHaveActiveParents\n         *\n         * @param col_index\n         * @param row_index\n         * @param exclude_coords\n         */\n        this.doesNodeHaveActiveParents = function (col_index, row_index, exclude_coords) {\n\n            if (row_index === 0) {\n                return false;\n            }\n\n            var result = false;\n            var parent_row_index = row_index - 1;\n            var parents = self.blocks[parent_row_index].columns;\n\n            _.forEach(parents, function (parent, parent_col_index) {\n                _.forEach(parent.lines, function (line) {\n\n                    // if parent coords are not equal to exclude coords\n                    // ... and parent has a line to this block\n                    // ... and parent is active\n                    if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && _.isEqual(line.to, [col_index, row_index]) && parent.active) {\n                        result = true;\n                    }\n                });\n            });\n\n            return result;\n        };\n\n        /**\n         * doesNodeHaveConnectedParents\n         *\n         * @param col_index\n         * @param row_index\n         * @param exclude_coords\n         */\n        this.doesNodeHaveConnectedParents = function (col_index, row_index, exclude_coords) {\n\n            if (row_index === 0) {\n                return false;\n            }\n\n            if (_.isUndefined(exclude_coords)) {\n                exclude_coords = [];\n            }\n\n            var result = false;\n            var parent_row_index = row_index - 1;\n            var parents = self.blocks[parent_row_index].columns;\n\n            _.forEach(parents, function (parent, parent_col_index) {\n\n                // if parent coords are not equal to exclude coords and parent is potential (potential parent node is always connected)\n                if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && self.isNodePotential([col_index, row_index], [parent_col_index, parent_row_index])) {\n\n                    result = true;\n                    return false;\n                }\n            });\n\n            return result;\n        };\n\n        /**\n         * isNodePotential\n         *\n         * @param source_coords\n         * @param target_coords\n         */\n        this.isNodePotential = function (source_coords, target_coords) {\n\n            // if not ready\n            if (_.isUndefined(self.blocks[target_coords[1]])) {\n                return false;\n            }\n            if (_.isUndefined(self.blocks[target_coords[1]].columns[target_coords[0]])) {\n                return false;\n            }\n\n            // refuse if control\n            if (self.blocks[target_coords[1]].columns[target_coords[0]].control) {\n                return false;\n            }\n\n            // refuse if same row\n            if (source_coords[1] === target_coords[1]) {\n                return false;\n            }\n\n            // refuse if spanning more than 1 rows\n            if (Math.abs(source_coords[1] - target_coords[1]) > 1) {\n                return false;\n            }\n\n            // target row index out of bounds check\n            if (target_coords[1] >= self.blocks.length) {\n                return false;\n            }\n\n            // target col index out of bounds check\n            if (target_coords[0] >= self.blocks[target_coords[1]].columns.length) {\n                return false;\n            }\n\n            // check if target is parent or child\n            var is_target_parent = target_coords[1] < source_coords[1];\n            var source = self.blocks[source_coords[1]].columns[source_coords[0]];\n            var target = self.blocks[target_coords[1]].columns[target_coords[0]];\n            var result;\n\n            // if target is parent, then check if target has connected lines to source\n            if (is_target_parent) {\n\n                result = false;\n\n                // check that last exit was not bottom\n                if (self.source_exit_side === 'bottom') {\n                    return false;\n                }\n\n                // check if target has an connected line from it source\n                _.forEach(target.lines, function (line) {\n                    if (line.connected && _.isEqual(line.to, source_coords)) {\n                        result = true;\n                        return false;\n                    }\n                });\n            }\n\n            // if target is child, then\n            else {\n\n                result = true;\n\n                // check that last exit was not top\n                if (self.source_exit_side === 'top') {\n                    return false;\n                }\n\n                // check if source does not have an connected line to it\n                _.forEach(source.lines, function (line) {\n                    if (line.connected && _.isEqual(line.to, target_coords)) {\n                        result = false;\n                        return false;\n                    }\n                });\n            }\n\n            return result;\n        };\n\n        //-----------------------------\n        // node classes\n        //-----------------------------\n\n        /**\n         * setLineClass\n         *\n         * @param source_coords\n         * @param target_coords\n         * @param key\n         * @param value\n         */\n        this.setLineClass = function (source_coords, target_coords, key, value) {\n\n            // loop child row columns\n            _.forEach(self.blocks[source_coords[1]].columns[source_coords[0]].lines, function (line) {\n\n                // if child node is potential then update class property\n                if (_.isEqual(line.to, target_coords)) {\n                    line[key] = value;\n                }\n            });\n        };\n\n        /**\n         * setNodeClass\n         *\n         * @param col_index\n         * @param row_index\n         * @param key\n         * @param value\n         */\n        this.setNodeClass = function (col_index, row_index, key, value) {\n            if (_.has(self.blocks[row_index].columns[col_index], key)) {\n                self.blocks[row_index].columns[col_index][key] = value;\n            }\n        };\n\n        /**\n         * setPotentialNodeClasses\n         *\n         * @param col_index\n         * @param row_index\n         * @param key\n         * @param value\n         */\n        this.setPotentialNodeClasses = function (col_index, row_index, key, value) {\n\n            self.setPotentialChildNodeClasses(col_index, row_index, key, value);\n            self.setPotentialParentNodeClasses(col_index, row_index, key, value);\n        };\n\n        /**\n         * setPotentialChildNodeClasses\n         *\n         * @param col_index\n         * @param row_index\n         * @param key\n         * @param value\n         */\n        this.setPotentialChildNodeClasses = function (col_index, row_index, key, value) {\n\n            // if child row is not out of bounds\n            if ((row_index + 1) < (self.blocks.length)) {\n\n                // loop child row columns\n                _.forEach(self.blocks[row_index + 1].columns, function (child_col, child_col_index) {\n\n                    // if child node is potential then update class property\n                    if (self.isNodePotential([col_index, row_index], [child_col_index, row_index + 1])) {\n                        child_col[key] = value;\n                    }\n                });\n            }\n        };\n\n        /**\n         * setPotentialParentNodeClasses\n         *\n         * @param col_index\n         * @param row_index\n         * @param key\n         * @param value\n         */\n        this.setPotentialParentNodeClasses = function (col_index, row_index, key, value) {\n\n            if (row_index > 0) {\n\n                // loop parent node columns\n                _.forEach(self.blocks[row_index - 1].columns, function (parent_col, parent_col_index) {\n\n                    // if parent node is potential then update class property\n                    if (self.isNodePotential([col_index, row_index], [parent_col_index, row_index - 1])) {\n                        parent_col[key] = value;\n                    }\n                });\n            }\n        };\n\n        //-----------------------------\n        // viewport\n        //-----------------------------\n\n        /**\n         * setViewport\n         *\n         * @param cols\n         * @param rows\n         */\n        this.setViewport = function (cols, rows) {\n\n            var total_item_width = BLOCK_WIDTH + COL_SPACING;\n            var total_item_height = BLOCK_HEIGHT + ROW_SPACING;\n\n            self.viewport_width = total_item_width * cols;\n            self.viewport_height = total_item_height * rows;\n\n            self.viewport_style = {\n                'background-color': \"#ccc\",\n                'min-width': self.viewport_width + \"px\",\n                'min-height': self.viewport_height + \"px\"\n            };\n\n            self.wrapper_style = {\n                'max-width': (self.viewport_width + MAX_VIEWPORT_WIDTH_INCREASE) + \"px\",\n                'min-width': self.viewport_width + \"px\",\n                'max-height': (self.viewport_height + (MAX_VIEWPORT_HEIGHT_INCREASE * rows)) + \"px\",\n                'min-height': self.viewport_height + \"px\"\n            };\n\n            self.viewport_viewbox = \" 0 0 \" + self.viewport_width + \" \" + self.viewport_height;\n        };\n\n        /**\n         * checkViewport\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.checkViewport = function (col_index, row_index) {\n\n            var should_update_viewport = false;\n\n            // row bounds check\n            if (row_index >= self.grid_row_count) {\n\n                // increase rowspan\n                self.grid_row_count++;\n                should_update_viewport = true;\n            }\n\n            // col bounds check\n            if (col_index >= self.grid_col_count) {\n\n                // increase colspan\n                self.grid_col_count++;\n                should_update_viewport = true;\n\n                // add bg grid col\n                self.addBgGridCol(self.grid_col_count - 1);\n            }\n\n            // set viewport\n            if (should_update_viewport) {\n                self.setViewport(self.grid_col_count, self.grid_row_count);\n            }\n        };\n\n        //-----------------------------\n        // coords\n        //-----------------------------\n\n        /**\n         * calculateColX\n         *\n         * @param index\n         */\n        this.calculateColX = function (index) {\n            if (index === 0) {\n                return 0;\n            }\n            var first_col_width = BLOCK_WIDTH + (COL_SPACING / 2);\n            var col_width = BLOCK_WIDTH + (COL_SPACING);\n            return first_col_width + ((index - 1) * col_width);\n        };\n\n        /**\n         * calculateColWidth\n         *\n         * @param index\n         */\n        this.calculateColWidth = function (index) {\n            var total_item_width = index === 0 ? BLOCK_WIDTH + (COL_SPACING / 2) : BLOCK_WIDTH + COL_SPACING;\n            return total_item_width;\n        };\n\n        /**\n         * calculateRowY\n         *\n         * @param index\n         */\n        this.calculateRowY = function (index) {\n            var row_height = BLOCK_HEIGHT + ROW_SPACING;\n            return index * row_height;\n        };\n\n        /**\n         * calculateRowHeight\n         *\n         * @param index\n         */\n        this.calculateRowHeight = function () {\n            return BLOCK_HEIGHT + ROW_SPACING;\n        };\n\n        /**\n         * getCoords\n         *\n         * @param position\n         * @param col_index\n         * @param row_index\n         * @returns {*}\n         */\n        this.getCoords = function (col_index, row_index, position) {\n\n            var total_width = BLOCK_WIDTH + COL_SPACING;\n            var total_height = BLOCK_HEIGHT + ROW_SPACING;\n\n            var x = ( col_index + 1 ) * total_width - total_width;\n            var y = ( row_index + 1 ) * total_height - total_height;\n\n            var result = null;\n\n            switch (position) {\n                case BLOCK_TOP_LEFT:\n                    result = [x, y];\n                    break;\n\n                case BLOCK_TOP:\n                    x += BLOCK_WIDTH / 2;\n                    result = [x, y];\n                    break;\n\n                case BLOCK_CENTER:\n                    x += BLOCK_WIDTH / 2;\n                    y += BLOCK_HEIGHT / 2;\n                    result = [x, y];\n                    break;\n\n                case BLOCK_BOTTOM:\n                    x += BLOCK_WIDTH / 2;\n                    y += BLOCK_HEIGHT;\n                    result = [x, y];\n                    break;\n            }\n            return result;\n        };\n\n        //-----------------------------\n        // drawing\n        //-----------------------------\n\n        /**\n         * addLine\n         *\n         * @param source_coords\n         * @param target_coords\n         */\n        this.addLine = function (source_coords, target_coords, connected) {\n\n            // check bounds\n            if (target_coords[1] >= self.blocks.length) {\n                return false;\n            }\n\n            // get coords\n            var source_lock_coords = self.getCoords(source_coords[0], source_coords[1], BLOCK_BOTTOM);\n            var target_lock_coords = self.getCoords(target_coords[0], target_coords[1], BLOCK_TOP);\n\n            // add line properties\n            self.blocks[source_coords[1]].columns[source_coords[0]].lines.push({\n                connected: !_.isUndefined(connected) ? connected : false,\n                from: source_coords,\n                to: target_coords,\n                x1: source_lock_coords[0],\n                y1: source_lock_coords[1],\n                x2: target_lock_coords[0],\n                y2: target_lock_coords[1]\n            });\n\n            if (connected) {\n                // update data\n                $s.rows[source_coords[1]].columns[source_coords[0]].join.push(target_coords[0]);\n            }\n        };\n\n        /**\n         * updateLineTarget\n         *\n         * @param source_coords\n         * @param target_coords\n         */\n        this.updateLineTarget = function (source_coords, target_coords) {\n\n            // get target lock coords\n            var target_lock_coords = self.getCoords(target_coords[0], target_coords[1], BLOCK_TOP);\n\n            // find line\n            _.forEach(self.blocks[source_coords[1]].columns[source_coords[0]].lines, function (line) {\n\n                if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                    line.x2 = target_lock_coords[0];\n                    line.y2 = target_lock_coords[1];\n                    line.to = target_coords;\n                    return false;\n                }\n            });\n        };\n\n        /**\n         * removeLine\n         *\n         * @param source_coords\n         * @param target_coords\n         */\n        this.removeLine = function (source_coords, target_coords) {\n\n            // get target lock coords\n            var target_lock_coords = self.getCoords(source_coords[0], source_coords[1], BLOCK_BOTTOM);\n\n            // find line\n            _.forEach(self.blocks[source_coords[1]].columns[source_coords[0]].lines, function (line) {\n\n                if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                    var block = self.blocks[target_coords[1]].columns[target_coords[0]];\n                    var block_has_connected_parents = self.doesNodeHaveConnectedParents(target_coords[0], target_coords[1], source_coords);\n\n                    // if block has no lines & has no parent connections\n                    if (block.lines.length === 0 && !block_has_connected_parents) {\n                        // set as not connected\n                        self.setAsNotConnectedBlock(target_coords);\n                    }\n\n                    // if block has no parent connections\n                    var block_has_active_parents = self.doesNodeHaveActiveParents(target_coords[0], target_coords[1], source_coords);\n\n                    if (!block_has_active_parents) {\n\n                        // deactivate block\n                        self.deactivateBlock(target_coords[0], target_coords[1]);\n                    }\n\n                    // set line properties\n                    line.x2 = target_lock_coords[0];\n                    line.y2 = target_lock_coords[1];\n                    line.previous_to = line.to; // TODO: this feels a bit hacky\n                    line.to = [source_coords[0], source_coords[1]];\n                    return false;\n                }\n            });\n        };\n\n        /**\n         * removeUnconnectedLines\n         *\n         * @param selection\n         */\n        this.removeUnconnectedLines = function (selection) {\n\n            _.forEach(self.blocks[selection[0][1]].columns[selection[0][0]].lines, function (line) {\n                if (!line.connected) {\n                    self.removeLine(self.selection[0], self.selection[1]);\n                }\n            });\n        };\n\n        /**\n         * setAsConnectedLines\n         *\n         * @param selection\n         */\n        this.setAsConnectedLines = function (selection) {\n\n            _.forEach(self.blocks[selection[0][1]].columns[selection[0][0]].lines, function (line, line_index) {\n                if (!line.connected) {\n\n                    // setAsConnected line\n                    line.connected = true;\n\n                    // setAsConnected blocks\n                    self.setAsConnectedBlock(line.from);\n                    self.setAsConnectedBlock(line.to);\n\n                    // update data\n                    $s.rows[line.from[1]].columns[line.from[0]].join.splice(line_index, 0, line.to[0]);\n\n                    // external handler\n                    if (!_.isUndefined($s.onLineAdd)) {\n                        $s.onLineAdd(self.getExternalLineEventHandlerData(line.from, line.to, line_index));\n                    }\n                }\n            });\n        };\n\n        /**\n         * setAsConnectedBlock\n         *\n         * @param coords\n         */\n        this.setAsConnectedBlock = function (coords) {\n            self.blocks[coords[1]].columns[coords[0]].connected = true;\n        };\n\n        /**\n         * setAsNotConnectedBlock\n         *\n         * @param coords\n         */\n        this.setAsNotConnectedBlock = function (coords) {\n            self.blocks[coords[1]].columns[coords[0]].connected = false;\n        };\n\n        /**\n         * addBlock\n         *\n         * @param col_index\n         * @param row_index\n         * @param label\n         * @param lines\n         * @returns {boolean}\n         */\n        this.addBlock = function (col_index, row_index, label, lines) {\n\n            if (row_index > self.blocks.length) {\n                throw new Error(\"Invalid row index\");\n            }\n\n            // create row if it doesn't exist\n            if (row_index === self.blocks.length) {\n                self.blocks.push({columns: []});\n            }\n\n            // if block already exists (control) then remove and re-add after block\n            var removed_block;\n\n            if (!_.isUndefined(self.blocks[row_index].columns[col_index])) {\n                removed_block = self.blocks[row_index].columns.splice(col_index, 1);\n            }\n\n            // get top left coords\n            var top_left_coords = self.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n\n            // lines\n            var block_lines = [];\n            var line_source_lock_coords = self.getCoords(col_index, row_index, BLOCK_BOTTOM);\n\n            _.forEach(lines, function (line_target_col_index) {\n\n                var line_target_coords = [line_target_col_index, row_index + 1];\n                var line_target_lock_coords = self.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP);\n\n                block_lines.push({\n                    connected: true,\n                    from: [col_index, row_index],\n                    to: line_target_coords,\n                    x1: line_source_lock_coords[0],\n                    y1: line_source_lock_coords[1],\n                    x2: line_target_lock_coords[0],\n                    y2: line_target_lock_coords[1]\n                });\n\n                // set blocks as connected\n                self.blocks_waiting_for_connection.push(line_target_coords);\n            });\n\n            // set block properties\n            var block = {\n                coords: top_left_coords,\n                x: top_left_coords[0],\n                y: top_left_coords[1],\n                label_x: top_left_coords[0] + LABEL_SPACING,\n                label_y: top_left_coords[1] + LABEL_SPACING,\n                label: label,\n                connected: block_lines.length > 0,\n                control: false,\n                row_index: row_index,\n                col_index: col_index,\n                lines: block_lines\n            };\n\n            // add block\n            self.blocks[row_index].columns.push(block);\n\n            // check viewport\n            self.checkViewport(col_index, row_index);\n\n            // replace removed block\n            if (!_.isUndefined(removed_block)) {\n                self.addControl(removed_block[0].row_index);\n            }\n        };\n\n        /**\n         * updateBlock\n         *\n         * @param col_index\n         * @param row_index\n         * @param label\n         */\n        this.updateBlock = function (col_index, row_index, label) {\n\n            // update label\n            if (!_.isUndefined(label) && self.blocks[row_index].columns[col_index].label !== label) {\n                self.blocks[row_index].columns[col_index].label = label;\n            }\n\n            // // update lines\n            // if (!_.isUndefined(lines)) {\n            //\n            //     var line_source_lock_coords     = self.getCoords(col_index, row_index, BLOCK_BOTTOM);\n            //\n            //     _.forEach(lines, function(line_target_col_index) {\n            //\n            //         var line_target_coords = [line_target_col_index, row_index + 1];\n            //         var line_target_lock_coords     = self.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP);\n            //\n            //         self.blocks[row_index].columns[col_index].lines.push({\n            //             connected: true,\n            //             from: [col_index, row_index],\n            //             to: line_target_coords,\n            //             x1: line_source_lock_coords[0],\n            //             y1: line_source_lock_coords[1],\n            //             x2: line_target_lock_coords[0],\n            //             y2: line_target_lock_coords[1]\n            //         });\n            //\n            //         self.setNodeClass(col_index, row_index, 'connected', true);\n            //\n            //         // set blocks as connected\n            //         self.blocks_waiting_for_connection.push(line_target_coords);\n            //     });\n            // }\n        };\n\n        /**\n         * removeBlock\n         *\n         * @param col_index\n         * @param row_index\n         */\n        this.removeBlock = function (col_index, row_index) {\n\n            if (row_index >= self.blocks.length) {\n                return true;\n            }\n\n            if (col_index >= self.blocks[row_index].columns.length - 1) {\n                return true;\n            }\n\n            // remove lines\n            _.forEach(self.blocks[row_index].columns[col_index].lines, function (line) {\n                self.removeLine(line.from, line.to);\n            });\n\n            // remove block\n            self.blocks[row_index].columns.splice(col_index, 1);\n\n            // update data\n            $s.rows[row_index].columns.splice(col_index, 1);\n\n            // update siblings\n            for (var i = col_index; i < (self.blocks[row_index].columns.length); i++) {\n                self.updateBlockAfterSiblingAddedOrRemoved(i, row_index);\n\n                // if not last column (control)\n                if (i < self.blocks[row_index].columns.length - 1) {\n                    $s.rows[row_index].columns[i].data.ui_column_index = i;\n                    $s.rows[row_index].columns[i].data.ui_row_index = row_index;\n                }\n            }\n\n            // update parents\n            if (row_index !== 0) {\n                var parent_row_index = row_index - 1;\n                _.forEach(self.blocks[parent_row_index].columns, function (column, parent_col_index) {\n                    _.forEach(column.lines, function (line, line_index) {\n\n                        // if parent connects to this node\n                        if (_.isEqual(line.to, [col_index, row_index])) {\n                            column.lines.splice(line_index, 1);\n\n                            // update data\n                            $s.rows[parent_row_index].columns[parent_col_index].join.splice(line_index, 1);\n\n                            // if parent no longer has any lines\n                            if (column.lines.length === 0) {\n                                self.setAsNotConnectedBlock([parent_col_index, parent_row_index]);\n                            }\n                        }\n\n                        // if parent connects to a sibling (right) then adjust line target col index\n                        if (line.to[0] > col_index) {\n\n                            // update lines target\n                            var new_line_to = [line.to[0] - 1, line.to[1]];\n\n                            // get target lock coords\n                            var target_lock_coords = self.getCoords(new_line_to[0], new_line_to[1], BLOCK_TOP);\n\n                            line.to = [new_line_to[0], new_line_to[1]];\n                            line.x2 = target_lock_coords[0];\n                            line.y2 = target_lock_coords[1];\n                        }\n                    });\n                });\n            }\n\n            // update children\n            if (row_index !== $s.rows.length - 1) {\n                var children_row_index = row_index + 1;\n                _.forEach(self.blocks[children_row_index].columns, function (column, children_col_index) {\n\n                    // if  block has no parent connections\n                    if (!self.doesNodeHaveConnectedParents(children_col_index, children_row_index)) {\n                        self.setAsNotConnectedBlock([children_col_index, children_row_index]);\n                    }\n                });\n            }\n        };\n\n        /**\n         * insertBlock\n         *\n         * @param col_index\n         * @param row_index\n         * @param data\n         */\n        this.insertBlock = function (col_index, row_index, data) {\n\n            if (row_index >= self.blocks.length) {\n                return true;\n            }\n\n            if (col_index > self.blocks[row_index].columns.length - 1) {\n                return true;\n            }\n\n            // get top left coords\n            var top_left_coords = self.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n\n            // lines\n            var block_lines = [];\n            var line_source_lock_coords = self.getCoords(col_index, row_index, BLOCK_BOTTOM);\n\n            _.forEach(data.join, function (line_target_col_index) {\n\n                var line_target_coords = [line_target_col_index, row_index + 1];\n                var line_target_lock_coords = self.getCoords(line_target_coords[0], line_target_coords[1], BLOCK_TOP);\n\n                block_lines.push({\n                    connected: true,\n                    from: [col_index, row_index],\n                    to: line_target_coords,\n                    x1: line_source_lock_coords[0],\n                    y1: line_source_lock_coords[1],\n                    x2: line_target_lock_coords[0],\n                    y2: line_target_lock_coords[1]\n                });\n\n                // set blocks as connected\n                self.blocks_waiting_for_connection.push(line_target_coords);\n            });\n\n            // set block properties\n            var block = {\n                coords: top_left_coords,\n                x: top_left_coords[0],\n                y: top_left_coords[1],\n                label_x: top_left_coords[0] + LABEL_SPACING,\n                label_y: top_left_coords[1] + LABEL_SPACING,\n                label: data.label,\n                connected: block_lines.length > 0,\n                control: false,\n                row_index: row_index,\n                col_index: col_index,\n                lines: block_lines\n            };\n\n            // insert block\n            self.blocks[row_index].columns.splice(col_index, 0, block);\n\n            // update data\n            $s.rows[row_index].columns.splice(col_index, 0, data);\n\n            // update siblings\n            for (var i = col_index + 1; i < (self.blocks[row_index].columns.length); i++) {\n\n                self.updateBlockAfterSiblingAddedOrRemoved(i, row_index);\n\n                // if not last column (control)\n                if (i < self.blocks[row_index].columns.length - 1) {\n                    $s.rows[row_index].columns[i].data.ui_column_index = i;\n                    $s.rows[row_index].columns[i].data.ui_row_index = row_index;\n                }\n            }\n\n            // update parents\n            if (row_index !== 0) {\n                var parent_row_index = row_index - 1;\n                _.forEach(self.blocks[parent_row_index].columns, function (column) {\n                    _.forEach(column.lines, function (line) {\n\n                        // if parent connects to a sibling (right) then adjust line target col index\n                        if (line.to[0] >= col_index) {\n\n                            // update lines target\n                            var new_line_to = [line.to[0] + 1, line.to[1]];\n\n                            // get target lock coords\n                            var target_lock_coords = self.getCoords(new_line_to[0], new_line_to[1], BLOCK_TOP);\n\n                            line.to = [new_line_to[0], new_line_to[1]];\n                            line.x2 = target_lock_coords[0];\n                            line.y2 = target_lock_coords[1];\n                        }\n                    });\n                });\n            }\n        };\n\n        /**\n         * updateBlockAfterSiblingAddedOrRemoved\n         *\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.updateBlockAfterSiblingAddedOrRemoved = function (col_index, row_index) {\n\n            var top_left_coords = self.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n            var center_coords = self.getCoords(col_index, row_index, BLOCK_CENTER);\n\n            // update block\n\n            self.blocks[row_index].columns[col_index].col_index = col_index;\n            self.blocks[row_index].columns[col_index].coords = top_left_coords;\n            self.blocks[row_index].columns[col_index].x = top_left_coords[0];\n            self.blocks[row_index].columns[col_index].y = top_left_coords[1];\n\n            // update labels\n            // last block has different label position\n            if (col_index === (self.blocks[row_index].columns.length - 1)) {\n                self.blocks[row_index].columns[col_index].label_x = center_coords[0];\n                self.blocks[row_index].columns[col_index].label_y = center_coords[1];\n            } else {\n                self.blocks[row_index].columns[col_index].label_x = top_left_coords[0] + LABEL_SPACING;\n                self.blocks[row_index].columns[col_index].label_y = top_left_coords[1] + LABEL_SPACING;\n            }\n\n            // update lines\n            _.forEach(self.blocks[row_index].columns[col_index].lines, function (line) {\n\n                // get target lock coords\n                var source_lock_coords = self.getCoords(col_index, row_index, BLOCK_TOP);\n\n                line.from = [col_index, row_index];\n                line.x1 = source_lock_coords[0];\n                line.y1 = source_lock_coords[1];\n            });\n\n            // check viewport\n            self.checkViewport(col_index, row_index);\n        };\n\n        /**\n         * updateBlockAfterChildAddedOrRemoved\n         *\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.updateBlockAfterChildAddedOrRemoved = function (col_index, row_index) {\n\n            var top_left_coords = self.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n            var center_coords = self.getCoords(col_index, row_index, BLOCK_CENTER);\n\n            // update block\n\n            self.blocks[row_index].columns[col_index].col_index = col_index;\n            self.blocks[row_index].columns[col_index].coords = top_left_coords;\n            self.blocks[row_index].columns[col_index].x = top_left_coords[0];\n            self.blocks[row_index].columns[col_index].y = top_left_coords[1];\n\n            // update labels\n            // last block has different label position\n            if (col_index === (self.blocks[row_index].columns.length - 1)) {\n                self.blocks[row_index].columns[col_index].label_x = center_coords[0];\n                self.blocks[row_index].columns[col_index].label_y = center_coords[1];\n            } else {\n                self.blocks[row_index].columns[col_index].label_x = top_left_coords[0] + LABEL_SPACING;\n                self.blocks[row_index].columns[col_index].label_y = top_left_coords[1] + LABEL_SPACING;\n            }\n\n            // update lines\n            _.forEach(self.blocks[row_index].columns[col_index].lines, function (line) {\n\n                // get target lock coords\n                var source_lock_coords = self.getCoords(col_index, row_index, BLOCK_TOP);\n\n                line.from = [col_index, row_index];\n                line.x1 = source_lock_coords[0];\n                line.y1 = source_lock_coords[1];\n            });\n\n            // check viewport\n            self.checkViewport(col_index, row_index);\n        };\n\n        /**\n         * addControl\n         *\n         * @param {Integer}    row_index\n         */\n        this.addControl = function (row_index) {\n\n            // create row if it doesn't exist\n            if (row_index === self.blocks.length) {\n                self.blocks.push({columns: []});\n            }\n\n            // validate row index\n            if (row_index >= self.blocks.length) {\n                throw new Error(\"Invalid row index\");\n            }\n\n            var col_index = self.blocks[row_index].columns.length;\n\n            // get top left coords\n            var top_left_coords = self.getCoords(col_index, row_index, BLOCK_TOP_LEFT);\n            var center_coords = self.getCoords(col_index, row_index, BLOCK_CENTER);\n\n            // set block properties\n            var block = {\n                coords: top_left_coords,\n                x: top_left_coords[0],\n                y: top_left_coords[1],\n                label_x: center_coords[0],\n                label_y: center_coords[1],\n                label: \"+\",\n                connected: false,\n                control: true,\n                row_index: row_index,\n                col_index: col_index,\n                lines: []\n            };\n\n            // add block\n            self.blocks[row_index].columns.push(block);\n\n            // check viewport\n            self.checkViewport(col_index, row_index);\n\n        };\n\n        /**\n         * addBgGridCol\n         *\n         * @param {Integer}    index\n         */\n        this.addBgGridCol = function (index) {\n\n            self.bg_col_grid.push({\n                index: index,\n                x: self.calculateColX(index),\n                width: self.calculateColWidth(index)\n            });\n        };\n\n        ////////////////////////////////////////////////\n        //\n        // watchers\n        //\n        ////////////////////////////////////////////////\n\n        $s.$watch('ctrl.selection', function (newValue, oldValue) {\n\n            if (!_.isUndefined(newValue)) {\n\n                // two selected & target is child of source\n                if (newValue.length === 2 && newValue[1][1] > newValue[0][1]) {\n\n                    // new target selection\n                    if (newValue.length > oldValue.length) {\n\n                        // add line\n                        self.addLine(self.selection[0], self.selection[1]);\n                    }\n\n                    // updated target selection\n                    else {\n\n                        // update line\n                        self.updateLineTarget(self.selection[0], self.selection[1]);\n                    }\n                }\n            }\n        }, true);\n\n        $s.$watch('rows', function (newValue) {\n\n            if (!_.isUndefined(newValue)) {\n\n                // init\n                if (!initialized) {\n                    self.init(newValue, 'columns');\n                    initialized = true;\n                    return true;\n                }\n\n                // update\n                self.update(newValue, 'columns');\n            }\n        }, true);\n\n        ////////////////////////////////////////////////\n        //\n        // init / update\n        //\n        ////////////////////////////////////////////////\n\n        /**\n         * init\n         *\n         * @param data\n         * @param column_property_name\n         */\n        this.init = function (data, column_property_name) {\n\n            // add placeholders\n            for (var row_index = 0; row_index < INITIAL_GRID_ROWS; row_index++) {\n\n                // add data placeholder\n                if (row_index >= data.length) {\n                    data.push({columns: []});\n                }\n            }\n\n            // add blocks\n            _.forEach(data, function (row, row_index) {\n\n                _.forEach(row[column_property_name], function (col, col_index) {\n\n                    // add block\n                    self.addBlock(col_index, row_index, col.label, col.join);\n                });\n\n                // add control\n                self.addControl(row_index);\n            });\n\n            // add bg_col_grid array\n            _.map(new Array(self.grid_col_count), function (col, index) {\n\n                // add bg grid col\n                self.addBgGridCol(index);\n            });\n\n            // set viewport\n            self.setViewport(self.grid_col_count, self.grid_row_count);\n\n            // check active\n            self.checkActive();\n        };\n\n        /**\n         * update\n         *\n         * @param data\n         * @param column_property_name\n         */\n        this.update = function (data, column_property_name) {\n\n            // add controls\n            _.forEach(data, function (row, row_index) {\n\n                // ... if row index exceeds or equals current UI rows\n                if (row_index >= self.blocks.length) {\n                    self.addControl(row_index);\n                }\n            });\n\n            // add blocks\n            _.forEach(data, function (row, row_index) {\n                _.forEach(row[column_property_name], function (col, col_index) {\n\n                    // update block\n                    self.updateBlock(col_index, row_index, col.label);\n\n                    // ... if column index exceeds or equals current UI cols (excluding control)\n                    if (col_index >= self.blocks[row_index].columns.length - 1) {\n                        var label = _.has(col, 'label') ? col.label : \"\";\n                        var lines = _.has(col, 'join') ? col.join : [];\n                        self.addBlock(col_index, row_index, label, lines);\n                    }\n                });\n            });\n\n            // set viewport\n            self.setViewport(self.grid_col_count, self.grid_row_count);\n\n            // check active\n            self.checkActive();\n        };\n\n        ////////////////////////////////////////////////\n        //\n        // api\n        //\n        ////////////////////////////////////////////////\n\n        /**\n         * addLine\n         *\n         * @param {Array}    source_coords\n         * @param {Array}    target_coords\n         * @param {Boolean}  connected\n         */\n\n        this.api.addLine = function (source_coords, target_coords, connected) {\n\n            // style block\n            self.setNodeClass(source_coords[0], source_coords[1], 'connected', true);\n\n            // set target as waiting for connection\n            self.blocks_waiting_for_connection.push(target_coords);\n\n            // add line\n            self.addLine(source_coords, target_coords, connected);\n        };\n\n        /**\n         * insertBlock\n         *\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         * @param {Object}     data\n         */\n\n        this.api.insertBlock = function (col_index, row_index, data) {\n            self.insertBlock(col_index, row_index, data);\n        };\n\n        /**\n         * removeBlock\n         *\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.api.removeBlock = function (col_index, row_index) {\n            self.removeBlock(col_index, row_index);\n        };\n\n        /**\n         * highlightBlock\n         *\n         * @param {Boolean}    value\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.api.highlightBlock = function (value, col_index, row_index) {\n\n            // style block\n            self.setNodeClass(col_index, row_index, 'highlight', value);\n        };\n\n        /**\n         * selectBlock\n         *\n         * @param {Boolean}    value\n         * @param {Integer}    col_index\n         * @param {Integer}    row_index\n         */\n        this.api.selectBlock = function (value, col_index, row_index) {\n\n            if (!_.isUndefined(col_index) && !_.isUndefined(col_index) && value) {\n                self.selected_node = [col_index, row_index];\n                return true;\n            }\n\n            self.selected_node = null;\n        };\n    };\n}\n\nAngularSvgNodesController.$inject = [\n    '$scope',\n    'BLOCK_TOP_LEFT',\n    'BLOCK_TOP',\n    'BLOCK_CENTER',\n    'BLOCK_BOTTOM',\n    'ACTION_ADD',\n    'ACTION_REMOVE',\n    'ACTION_UPDATE',\n    'INITIAL_GRID_COLS',\n    'INITIAL_GRID_ROWS',\n    'BLOCK_WIDTH',\n    'BLOCK_HEIGHT',\n    'COL_SPACING',\n    'ROW_SPACING',\n    'LABEL_SPACING',\n    'DISABLE_CONTROL_NODES',\n    'MAX_VIEWPORT_WIDTH_INCREASE',\n    'MAX_VIEWPORT_HEIGHT_INCREASE'\n];"],"sourceRoot":"src/app/*.js"}