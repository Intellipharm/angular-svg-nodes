{"version":3,"sources":["angular-svg-nodes-controller.js"],"names":["Utils","NodeUtils","ApiValidator","AngularSvgNodesController","$s","_","isUndefined","api","state","config","new_node_label","config_new_node_label","initial_grid_cols","config_initial_grid_cols","initial_grid_rows","config_initial_grid_rows","highlight_node_on","config_highlight_node_on","node_width","config_node_width","node_height","config_node_height","col_spacing","config_col_spacing","row_spacing","config_row_spacing","label_spacing","config_label_spacing","disable_control_nodes","config_disable_control_nodes","max_viewport_width_increase","config_max_viewport_width_increase","max_viewport_height_increase","config_max_viewport_height_increase","is_initialising","was_connection_change_called","is_connection_change_busy","nodes_waiting_for_connection","parent_coords","coords","nodes","bg_col_grid","bg_col_grid_hover_index","grid_col_count","grid_row_count","label_width","label_height","wrapper_style","viewport_style","viewport_width","viewport_height","viewport_viewbox","selection","source_exit_side","selected_node","highlight_selected_node","new_node","$watch","onSelectionChange","bind","onInitialStateChange","addRow","label","_row_index","length","_col_index","addNode","addControlNode","removeNode","row_index","col_index","areApiCoordsValid","insertNode","connections","areApiCoordsValidForInsert","areApiConnectionsValid","updateNodeConnections","_label","columns","_lines","map","lines","line","has","to","_connections","uniq","updateNode","setNodeLabel","setNodeHighlight","value","highlight","_column_property_name","_data","initial_state","forEach","row","col","Array","index","addBgGridCol","setViewport","checkActive","update","newValue","oldValue","addLine","updateLineTarget","init","control","onControlNodeSelect","onNodeNodeSelect","includes","selected","onNodeSelectionCallback","onNodeNodeDeselect","_is_new_node","isEqual","onNodeDeselectionCallback","onControlNodeMouseOver","onNodeNodeMouseOver","exit_side","onControlNodeMouseOut","onNodeNodeMouseOut","isFunction","$apply","setNodeClass","setPotentialNodeClasses","doesNodeHaveConnectedParents","isNodePotential","is_target_parent","removeLine","setAsConnectedLines","setLineClass","isNull","setPotentialChildNodeClasses","setPotentialParentNodeClasses","target_coords","push","target_row_index","Math","abs","removeUnconnectedLines","source_coords","line_index","source","_was_line_connected","connected","splice","setAsNotConnectedNode","onNodeConnectionChangeCallback","_params","source_row_index","source_col_index","target_col_index","is_connected","is_node_waiting_for_connection","node","setAsConnectedNode","count","activateNode","Object","assign","active","does_parent_have_active_nodes","doesNodeHaveActiveParents","deactivateNode","exclude_coords","result","parent_row_index","parents","parent","parent_col_index","target","key","child_col","child_col_index","parent_col","cols","rows","total_item_width","total_item_height","should_update_viewport","first_col_width","col_width","row_height","source_lock_coords","getNodeCoords","target_lock_coords","from","x1","y1","x2","y2","set_as_busy","node_has_connected_parents","node_has_active_parents","previous_to","data","removed_node","top_left_coords","node_lines","line_source_lock_coords","line_target_col_index","line_target_coords","line_target_lock_coords","x","y","label_x","label_y","checkViewport","onNodeAddedCallback","_set_as_busy","i","updateNodeAfterSiblingAddedOrRemoved","remove_lines","column","new_line_to","children_row_index","children_col_index","joins","center_coords","Error","calculateColX","width","calculateColWidth","column_property_name","$inject"],"mappings":"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","file":"angular-svg-nodes-controller.js","sourcesContent":["// local: constants\nimport {\n    HIGHLIGHT_NODE_ON_SELECT,\n    HIGHLIGHT_NODE_ON_DESELECT,\n    HIGHLIGHT_NODE_ON_ADD,\n    DEFAULT_HIGHLIGHT_NODE_ON,\n    DEFAULT_INITIAL_GRID_COLS,\n    DEFAULT_INITIAL_GRID_ROWS,\n    DEFAULT_NODE_WIDTH,\n    DEFAULT_NODE_HEIGHT,\n    DEFAULT_COL_SPACING,\n    DEFAULT_ROW_SPACING,\n    DEFAULT_LABEL_SPACING,\n    DEFAULT_DISABLE_CONTROL_NODES,\n    DEFAULT_MAX_VIEWPORT_WIDTH_INCREASE,\n    DEFAULT_MAX_VIEWPORT_HEIGHT_INCREASE\n} from \"./angular-svg-nodes-settings\";\nimport {\n    NODE_TOP_LEFT,\n    NODE_TOP,\n    NODE_CENTER,\n    NODE_BOTTOM,\n    DEFAULT_NEW_NODE_LABEL\n} from \"./node/node-settings\";\n\n// local: services\nimport * as Utils from './angular-svg-nodes-utils';\nimport * as NodeUtils from './node/node-utils';\nimport * as ApiValidator from './api/api-validator';\n\n// local: models\nimport AngularSvgNode from './node/node-model';\nimport AngularSvgNodeRow from './row/row-model';\nimport AngularSvgNodeLine from './line/line-model';\n\nexport default class AngularSvgNodesController {\n\n    constructor($s) {\n\n        this.$s = $s;\n\n        //-----------------------------\n        // directives vars\n        //-----------------------------\n        //\n        // this.initial_state\n        // this.api\n        //\n        //-----------------------------\n\n        if (_.isUndefined(this.api)) {\n            this.api = {};\n        }\n\n        //-----------------------------\n        // state\n        //-----------------------------\n\n        this.state = [];\n\n        //-----------------------------\n        // config\n        //-----------------------------\n\n        // TODO: validate highlight node on array (remove invalid options)\n\n        this.config = {\n            new_node_label:                 !_.isUndefined(this.config_new_node_label) ? this.config_new_node_label : DEFAULT_NEW_NODE_LABEL,\n            initial_grid_cols:              !_.isUndefined(this.config_initial_grid_cols) ? this.config_initial_grid_cols : DEFAULT_INITIAL_GRID_COLS,\n            initial_grid_rows:              !_.isUndefined(this.config_initial_grid_rows) ? this.config_initial_grid_rows : DEFAULT_INITIAL_GRID_ROWS,\n            highlight_node_on:              !_.isUndefined(this.config_highlight_node_on) ? this.config_highlight_node_on : DEFAULT_HIGHLIGHT_NODE_ON,\n            node_width:                     !_.isUndefined(this.config_node_width) ? this.config_node_width : DEFAULT_NODE_WIDTH,\n            node_height:                    !_.isUndefined(this.config_node_height) ? this.config_node_height : DEFAULT_NODE_HEIGHT,\n            col_spacing:                    !_.isUndefined(this.config_col_spacing) ? this.config_col_spacing : DEFAULT_COL_SPACING,\n            row_spacing:                    !_.isUndefined(this.config_row_spacing) ? this.config_row_spacing : DEFAULT_ROW_SPACING,\n            label_spacing:                  !_.isUndefined(this.config_label_spacing) ? this.config_label_spacing : DEFAULT_LABEL_SPACING,\n            disable_control_nodes:          !_.isUndefined(this.config_disable_control_nodes) ? this.config_disable_control_nodes : DEFAULT_DISABLE_CONTROL_NODES,\n            max_viewport_width_increase:    !_.isUndefined(this.config_max_viewport_width_increase) ? this.config_max_viewport_width_increase : DEFAULT_MAX_VIEWPORT_WIDTH_INCREASE,\n            max_viewport_height_increase:   !_.isUndefined(this.config_max_viewport_height_increase) ? this.config_max_viewport_height_increase : DEFAULT_MAX_VIEWPORT_HEIGHT_INCREASE\n        };\n\n        //-----------------------------\n        // control\n        //-----------------------------\n\n        this.is_initialising = false;\n\n        // allows onNodeDeselection to decide whether or not to fire external callback straight after onConnectionChange callback was fired\n        this.was_connection_change_called = false;\n        this.is_connection_change_busy = false;\n\n        // an array of node coords that will be set as connected on teh line\n        this.nodes_waiting_for_connection = [];\n\n        // parent coordinates (for reference)\n        this.parent_coords = [];\n\n        // view coordinates (for reference)\n        this.coords = [];\n\n        // view element data\n        this.nodes = [];\n\n        // array for bg grid\n        this.bg_col_grid = [];\n        this.bg_col_grid_hover_index = null;\n\n        // grid dimmensions\n        this.grid_col_count = this.config.initial_grid_cols;\n        this.grid_row_count = this.config.initial_grid_rows;\n        this.label_width = this.config.node_width - (this.config.label_spacing * 2);\n        this.label_height = this.config.node_height - (this.config.label_spacing * 2);\n\n        // viewport style & bounds\n        this.wrapper_style = \"\";\n        this.viewport_style = \"\";\n        this.viewport_width = 0;\n        this.viewport_height = 0;\n        this.viewport_viewbox = \"\";\n\n        // node selections\n        this.selection = [];\n        this.source_exit_side = null;\n\n        // active node\n        this.selected_node = [];\n\n        // highlighted selected node\n        this.highlight_selected_node = {};\n\n        this.new_node = {};\n\n        ////////////////////////////////////////////////\n        //\n        // watchers\n        //\n        ////////////////////////////////////////////////\n\n        this.$s.$watch('AngularSvgNodes.selection', this.onSelectionChange.bind(this), true);\n        this.$s.$watch('AngularSvgNodes.initial_state', this.onInitialStateChange.bind(this));\n\n        ////////////////////////////////////////////////\n        //\n        // api\n        //\n        ////////////////////////////////////////////////\n\n        /**\n         * addRow\n         *\n         * @param label\n         */\n        this.api.addRow = (label = \"\") => {\n\n            let _row_index = this.nodes.length;\n            let _col_index = 0;\n\n            this.addNode(_row_index, _col_index, label, []);\n            this.addControlNode(_row_index);\n        };\n\n        /**\n         * removeNode\n         *\n         * @param row_index\n         * @param col_index\n         */\n        this.api.removeNode = (row_index, col_index) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.removeNode(row_index, col_index);\n        };\n\n        /**\n         * insertNode\n         *\n         * @param row_index\n         * @param col_index\n         * @param label\n         * @param connections\n         */\n        this.api.insertNode = (row_index, col_index, label, connections) => {\n\n            if (!ApiValidator.areApiCoordsValidForInsert(this.nodes, row_index, col_index)) {\n                return;\n            }\n            if (!ApiValidator.areApiConnectionsValid(this.nodes, row_index - 1, connections)) {\n                return;\n            }\n\n            this.insertNode(row_index, col_index, label, connections);\n        };\n\n        /**\n         * updateNodeConnections\n         *\n         * @param row_index\n         * @param col_index\n         * @param connections\n         */\n        this.api.updateNodeConnections = (row_index, col_index, connections) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n            if (!ApiValidator.areApiConnectionsValid(this.nodes, row_index, connections)) {\n                return;\n            }\n\n            let _label = this.nodes[ row_index ].columns[ col_index ].label;\n            let _lines = _.map(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n                return _.has(line, 'to') ? line.to[0] : line;\n            });\n            let _connections = _.uniq([ ..._lines, ...connections ]);\n\n            this.updateNode(row_index, col_index, _label, _connections);\n        };\n\n        /**\n         * setNodeLabel\n         *\n         * @param row_index\n         * @param col_index\n         * @param label\n         */\n        this.api.setNodeLabel = (row_index, col_index, label) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.updateNode(row_index, col_index, label);\n        };\n\n        /**\n         * setNodeHighlight\n         *\n         * @param row_index\n         * @param col_index\n         * @param value\n         */\n        this.api.setNodeHighlight = (row_index, col_index, value) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.nodes[ row_index ].columns[ col_index ].highlight = value;\n        };\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // init\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * init\n     */\n    init() {\n\n        this.is_initialising = true;\n\n        // resets\n        this.nodes = [];\n\n        let _column_property_name = 'columns';\n        let _data = !_.isUndefined(this.initial_state) ?  this.initial_state : [];\n\n        // add nodes\n        _.forEach(_data, (row, row_index) => {\n\n            _.forEach(row[ _column_property_name ], (col, col_index) => {\n\n                this.addNode(row_index, col_index, col.label, col.connections, col);\n            });\n\n            this.addControlNode(row_index);\n        });\n\n        // add bg_col_grid array\n        _.map(new Array(this.grid_col_count), (col, index) => {\n            this.addBgGridCol(index);\n        });\n\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        this.checkActive();\n\n        this.update(_data, _column_property_name);\n\n        this.is_initialising = false;\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // watcher handlers\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * handles changes to the this.selection property\n     *\n     * @param newValue\n     * @param oldValue\n     */\n    onSelectionChange (newValue, oldValue) {\n\n        if (_.isUndefined(newValue)) {\n            return;\n        }\n\n        // two selected & target is child of source\n        if (newValue.length === 2 && newValue[1][1] > newValue[0][1]) {\n\n            // new target selection\n            if (newValue.length > oldValue.length) {\n\n                // add line\n                this.addLine(this.selection[0], this.selection[1]);\n            }\n\n            // updated target selection\n            else {\n\n                // update line\n                this.updateLineTarget(this.selection[0], this.selection[1]);\n            }\n        }\n    }\n\n    /**\n     * handles changes to initial_state property\n     *\n     * @param newValue\n     * @param oldValue\n     */\n    onInitialStateChange (newValue, oldValue) {\n        this.init();\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // view handlers\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // general\n    //-----------------------------\n\n    /**\n     * onNodeSelect\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onNodeSelect(row_index, col_index) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            if (!this.config.disable_control_nodes) {\n                this.onControlNodeSelect(row_index, col_index);\n            }\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeSelect(row_index, col_index);\n\n        // highlight node\n        // ... if configured to do so\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_SELECT)) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[ row_index ].columns[ col_index ].selected = true;\n        }\n\n        // external callback\n        if (!_.isUndefined(this.onNodeSelectionCallback)) {\n            this.onNodeSelectionCallback({ row_index, col_index });\n        }\n    }\n\n    /**\n     * onNodeDeselect\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onNodeDeselect(row_index, col_index) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            return false;\n        }\n\n        // if node\n        this.onNodeNodeDeselect(row_index, col_index);\n\n        let _is_new_node = _.isEqual(this.new_node, { row_index, col_index });\n\n        // highlight node\n        // ... if configured to do so\n        // ... and node is not new node (just added)\n        // ... and connection change callback was not just called\n        // ... and connection change is not busy (happens on line remove)\n\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_DESELECT) && !_is_new_node && !this.was_connection_change_called && !this.is_connection_change_busy) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[ row_index ].columns[ col_index ].selected = true;\n        }\n\n        // external callback\n        // ... if connection change callback was not just called\n        // ... and connection change is not busy (happens on line remove)\n\n        if (!_.isUndefined(this.onNodeDeselectionCallback) && !_is_new_node && !this.was_connection_change_called && !this.is_connection_change_busy) {\n            this.onNodeDeselectionCallback({ row_index, col_index });\n        }\n\n        this.new_node = {}; // reset\n        this.was_connection_change_called = false; // reset\n    }\n\n    /**\n     * onNodeMouseOver\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onNodeMouseOver(row_index, col_index) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            this.onControlNodeMouseOver(row_index, col_index);\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeMouseOver(row_index, col_index);\n    }\n\n    /**\n     * onNodeMouseOut\n     *\n     * @param row_index\n     * @param col_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeMouseOut(row_index, col_index, exit_side) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            this.onControlNodeMouseOut(row_index, col_index);\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeMouseOut(row_index, col_index, exit_side);\n    }\n\n    //-------------------------------------------------\n    // control node handlers\n    //-------------------------------------------------\n\n    /**\n     * onControlNodeSelect\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onControlNodeSelect(row_index, col_index) {\n\n        let _label = _.isFunction(this.config.new_node_label) ? this.config.new_node_label(row_index, col_index) : this.config.new_node_label;\n\n        this.addNode(row_index, col_index, _label, []);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOver\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onControlNodeMouseOver(row_index, col_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(row_index, col_index, 'control_hover', true);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOut\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onControlNodeMouseOut(row_index, col_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(row_index, col_index, 'control_hover', false);\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // node node handlers\n    //-------------------------------------------------\n\n    /**\n     * onNodeNodeSelect\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onNodeNodeSelect(row_index, col_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        this.setNodeClass(row_index, col_index, 'source_hover', false);\n        this.setNodeClass(row_index, col_index, 'source', true);\n        this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', false);\n        this.setPotentialNodeClasses(row_index, col_index, 'potential_target', true);\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // set selection\n        this.selection = [[ col_index, row_index ]];\n        this.selected_node = [ col_index, row_index ];\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onNodeNodeDeselect\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onNodeNodeDeselect(row_index, col_index) {\n\n        // reset last exit side\n        this.source_exit_side = null;\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if one selection\n        if (this.selection.length === 1) {\n\n            // if deselecting on current source\n            if (_.isEqual(this.selection[0], [ col_index, row_index ])) {\n\n                this.setNodeClass(row_index, col_index, 'source', false);\n                this.setNodeClass(row_index, col_index, 'source_hover', true);\n                this.setPotentialNodeClasses(row_index, col_index, 'potential_target', false);\n                this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', true);\n            }\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if deselecting on current target (& is potential ?)\n            if (_.isEqual(this.selection[1], [ col_index, row_index ])) {\n\n                this.setNodeClass(row_index, col_index, 'target', false);\n\n                // if  node has no parent connections\n                if (!this.doesNodeHaveConnectedParents(row_index, col_index)) {\n                    this.setPotentialNodeClasses(row_index, col_index, 'potential_target', false);\n                }\n\n                // check active\n                this.checkActive();\n            }\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // if deselecting on current target & is potential\n            if (_.isEqual(this.selection[1], [ col_index, row_index ]) && this.isNodePotential(this.selection[0], [ col_index, row_index ])) {\n\n                let is_target_parent = this.selection[0][1] > row_index;\n\n                // if target is parent then remove line\n                if (is_target_parent) {\n                    this.removeLine(this.selection[1], this.selection[0]);\n                }\n\n                // if target is child then setAsConnected line\n                else {\n                    this.setAsConnectedLines(this.selection);\n\n                    // check active\n                    this.checkActive();\n                }\n            }\n        }\n    }\n\n    /**\n     * onNodeNodeMouseOver\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onNodeNodeMouseOver(row_index, col_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selection\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(row_index, col_index, 'source_hover', true);\n            this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', true);\n        }\n\n        // if two selections\n        if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [ col_index, row_index ])) {\n                this.setNodeClass(row_index, col_index, 'potential_target', false);\n                this.setNodeClass(row_index, col_index, 'target', true);\n                this.setLineClass(this.selection[0], [ col_index, row_index ], 'target', true);\n            }\n        }\n\n        // if col changed\n        if (this.bg_col_grid_hover_index !== col_index) {\n\n            //this.bg_col_grid_hover_index = col_index;\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // if 2 selections and new col index is potential\n            //if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [col_index, this.selection[1][1]])) {\n            //    this.selection[1][0] = col_index;\n            //}\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onNodeNodeMouseOut\n     *\n     * @param row_index\n     * @param col_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeNodeMouseOut(row_index, col_index, exit_side) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selections\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(row_index, col_index, 'source_hover', false);\n            this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', false);\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [ col_index, row_index ])) {\n\n                this.setNodeClass(row_index, col_index, 'target', false);\n                this.setNodeClass(row_index, col_index, 'potential_target', true);\n                this.setLineClass(this.selection[0], [ col_index, row_index ], 'target', false);\n            }\n        }\n\n        // if this is source selection & source_exit_side not yet set\n        if (_.isEqual(this.selection[0], [ col_index, row_index ]) && _.isNull(this.source_exit_side)) {\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                // remove 'potential child' class from potential children\n                this.setPotentialChildNodeClasses(row_index, col_index, 'potential_target', false);\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                // remove 'potential child' class from potential parent\n                this.setPotentialParentNodeClasses(row_index, col_index, 'potential_target', false);\n            }\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if one selection one selected\n        if (this.selection.length === 1) {\n\n            // if this is source selection\n            if (_.isEqual(this.selection[0], [ col_index, row_index ])) {\n\n                // update source exit side\n                this.source_exit_side = exit_side;\n            }\n\n            let target_coords;\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                target_coords = [ this.bg_col_grid_hover_index, row_index - 1 ];\n\n                // if target is potential\n                if (this.isNodePotential([ col_index, row_index ], target_coords)) {\n                    this.selection.push(target_coords);\n                }\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                let target_row_index = row_index + 1;\n                target_coords = [ this.bg_col_grid_hover_index, target_row_index ];\n\n                // if not spanning more than one row && target is potential\n                if (Math.abs(this.selection[0][1] - target_row_index) <= 1 && this.isNodePotential([ col_index, row_index ], target_coords)) {\n\n                    this.selection.push(target_coords);\n                }\n            }\n        }\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // grid handlers\n    //-------------------------------------------------\n\n    /**\n     * onRootDeselect\n     */\n    onRootDeselect() {\n\n        // reset source_exit_side\n        this.source_exit_side = null;\n\n        // nothing to do if there are no selections\n        if (this.selection.length === 0) {\n            return true;\n        }\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if selections\n        if (this.selection.length > 0) {\n\n            this.setNodeClass(this.selection[0][1], this.selection[0][0], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // reset if there are not 2 selections\n        if (this.selection.length > 0) {\n            this.selection = [];\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBgColGridMouseOver\n     */\n    onBgColGridMouseOver(index) {\n\n        // do nothing if unchanged\n        if (this.bg_col_grid_hover_index === index) {\n            return true;\n        }\n\n        this.bg_col_grid_hover_index = index;\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            let target_coords = this.source_exit_side === 'top' ? [index, this.selection[0][1] - 1] : [index, this.selection[0][1] + 1];\n\n            // if target is potential\n            if (this.isNodePotential(this.selection[0], target_coords)) {\n                this.selection.push(target_coords);\n            }\n        }\n\n        // if 2 selections and new col index is potential\n        else if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [index, this.selection[1][1]])) {\n            this.selection[1][0] = index;\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onRootMouseLeave\n     */\n    onRootMouseLeave() {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            this.setNodeClass(this.selection[0][1], this.selection[0][0], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'potential_target', false);\n        }\n\n        // if 2 selections\n        else if (this.selection.length === 2) {\n\n            this.setNodeClass(this.selection[0][1], this.selection[0][0], 'source', false);\n            this.setNodeClass(this.selection[1][1], this.selection[1][0], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        this.selection = [];\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // line handlers\n    //-------------------------------------------------\n\n    /**\n     * onLineRemoveComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineRemoveComplete(source_coords, target_coords, line_index) {\n\n        // update data\n        //this.state[source_coords[1]].columns[source_coords[0]].connections.splice(line_index, 1);\n\n        // update nodes\n        let source = this.nodes[source_coords[1]].columns[source_coords[0]];\n\n        let _was_line_connected = source.lines[ line_index ].connected;\n\n        // delete line\n        source.lines.splice(line_index, 1);\n\n        // if source node has no more lines then setAsNotConnected\n        if (source.lines.length === 0) {\n\n            // if  node has no parent connections\n            if (!this.doesNodeHaveConnectedParents(source_coords[1], source_coords[0])) {\n                this.setAsNotConnectedNode([ source_coords[0], source_coords[1] ]);\n            }\n        }\n\n        // external callback\n        // ... if line was connected\n        // ... dotted temp line used for showing intended target is not connected, and it's removal should not trigger callback\n        if (!_.isUndefined(this.onNodeConnectionChangeCallback) && _was_line_connected) {\n\n            // don't need to set here because this happens after onNodeDeselection\n            // this.was_connection_change_called = true;\n\n            let _params = {\n                source_row_index: source_coords[1],\n                source_col_index: source_coords[0],\n                target_row_index: target_coords[1],\n                target_col_index: target_coords[0],\n                is_connected: false\n            };\n            this.onNodeConnectionChangeCallback(_params);\n        }\n\n        this.is_connection_change_busy = false;\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onLineDrawComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineDrawComplete(source_coords, target_coords) {\n\n        let is_node_waiting_for_connection = false;\n\n        _.forEach(this.nodes_waiting_for_connection, (node, index) => {\n            if (_.isEqual(node, target_coords)) {\n                is_node_waiting_for_connection = true;\n                this.nodes_waiting_for_connection.splice(index, 1);\n                return false;\n            }\n        });\n\n        if (is_node_waiting_for_connection) {\n\n            // connect node\n            this.setAsConnectedNode(target_coords);\n\n            // check active\n            this.checkActive();\n        }\n\n        this.$s.$apply();\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // utils\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // active check\n    //-----------------------------\n\n    /**\n     * checkActive\n     */\n    checkActive () {\n\n        this.count = 0;\n\n        if (this.nodes.length === 0) {\n            return false;\n        }\n\n        _.forEach(this.nodes[0].columns, (col, col_index) => {\n            if (col.lines.length > 0) {\n                this.activateNode(0, col_index);\n            }\n        });\n    }\n\n    /**\n     * activateNode\n     *\n     * @param row_index\n     * @param col_index\n     */\n    activateNode(row_index, col_index) {\n\n        // console.log(\"activateNode: \"+row_index+\" \"+col_index);\n\n        let node = Object.assign({}, this.nodes[ row_index ].columns[ col_index ]);\n\n        node.active = true;\n\n        if (node.lines.length > 0) {\n\n            _.forEach(node.lines, (line) => {\n\n                // activate line\n                line.active = true;\n\n                // activate target node\n                this.activateNode(line.to[1], line.to[0]);\n            });\n        }\n\n        // TODO: assigning new values for each node causes new instances of nodes (with new angular scope) to be created which causes all the line to redraw\n        this.nodes[ row_index ].columns[ col_index ] = node;\n        // this.nodes[ row_index ].columns[ col_index ] = new AngularSvgNode(node);\n\n        // this.nodes = NodeUtils.updateNodesActivateNode(this.nodes, row_index, col_index);\n    }\n\n    /**\n     * deactivateNode\n     *\n     * @param row_index\n     * @param col_index\n     */\n    deactivateNode(row_index, col_index) {\n\n        let node = this.nodes[ row_index ].columns[ col_index ];\n        node.active = false;\n\n        if (node.lines.length > 0) {\n            _.forEach(node.lines, (line) => {\n\n                // deactivate line\n                line.active = false;\n\n                let does_parent_have_active_nodes = this.doesNodeHaveActiveParents(line.to[1], line.to[0]);\n\n                // deactivate target node if no active parents\n                if (!does_parent_have_active_nodes) {\n                    this.deactivateNode(line.to[1], line.to[0]);\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // node potential\n    //-----------------------------\n\n    /**\n     * doesNodeHaveActiveParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveActiveParents(row_index, col_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        let result = false;\n        let parent_row_index = row_index - 1;\n        let parents = this.nodes[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n            _.forEach(parent.lines, (line) => {\n\n                // if parent coords are not equal to exclude coords\n                // ... and parent has a line to this node\n                // ... and parent is active\n                if (!_.isEqual([ parent_col_index, parent_row_index ], exclude_coords) && _.isEqual(line.to, [ col_index, row_index ]) && parent.active) {\n                    result = true;\n                }\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * doesNodeHaveConnectedParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveConnectedParents(row_index, col_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        if (_.isUndefined(exclude_coords)) {\n            exclude_coords = [];\n        }\n\n        let result = false;\n        let parent_row_index = row_index - 1;\n        let parents = this.nodes[ parent_row_index ].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n\n            // if parent coords are not equal to exclude coords and parent is potential (potential parent node is always connected)\n            if (!_.isEqual([ parent_col_index, parent_row_index ], exclude_coords) && this.isNodePotential([ col_index, row_index ], [ parent_col_index, parent_row_index ])) {\n\n                result = true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * isNodePotential\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    isNodePotential(source_coords, target_coords) {\n\n        // if not ready\n        if (_.isUndefined(this.nodes[ target_coords[1] ])) {\n            return false;\n        }\n        if (_.isUndefined(this.nodes[ target_coords[1] ].columns[ target_coords[0] ])) {\n            return false;\n        }\n\n        // refuse if control\n        if (this.nodes[ target_coords[1] ].columns[ target_coords[0] ].control) {\n            return false;\n        }\n\n        // refuse if same row\n        if (source_coords[1] === target_coords[1]) {\n            return false;\n        }\n\n        // refuse if spanning more than 1 rows\n        if (Math.abs(source_coords[1] - target_coords[1]) > 1) {\n            return false;\n        }\n\n        // target row index out of bounds check\n        if (target_coords[1] >= this.nodes.length) {\n            return false;\n        }\n\n        // target col index out of bounds check\n        if (target_coords[0] >= this.nodes[ target_coords[1] ].columns.length) {\n            return false;\n        }\n\n        // check if target is parent or child\n        let is_target_parent = target_coords[1] < source_coords[1];\n        let source = this.nodes[ source_coords[1] ].columns[ source_coords[0] ];\n        let target = this.nodes[ target_coords[1] ].columns[ target_coords[0] ];\n        let result;\n\n        // if target is parent, then check if target has connected lines to source\n        if (is_target_parent) {\n\n            result = false;\n\n            // check that last exit was not bottom\n            if (this.source_exit_side === 'bottom') {\n                return false;\n            }\n\n            // check if target has an connected line from it source\n            _.forEach(target.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, source_coords)) {\n                    result = true;\n                    return false;\n                }\n            });\n        }\n\n        // if target is child, then\n        else {\n\n            result = true;\n\n            // check that last exit was not top\n            if (this.source_exit_side === 'top') {\n                return false;\n            }\n\n            // check if source does not have an connected line to it\n            _.forEach(source.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, target_coords)) {\n                    result = false;\n                    return false;\n                }\n            });\n        }\n\n        return result;\n    }\n\n    //-----------------------------\n    // node classes\n    //-----------------------------\n\n    /**\n     * setLineClass\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param key\n     * @param value\n     */\n    setLineClass(source_coords, target_coords, key, value) {\n\n        // loop child row columns\n        _.forEach(this.nodes[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            // if child node is potential then update class property\n            if (_.isEqual(line.to, target_coords)) {\n                line[ key ] = value;\n            }\n        });\n    }\n\n    /**\n     * setNodeClass\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setNodeClass(row_index, col_index, key, value) {\n\n        // TODO: why was I doing this?\n        // if (_.has(this.nodes[ row_index ].columns[ col_index ], key)) {\n        //     this.nodes[ row_index ].columns[ col_index ][ key ] = value;\n        // }\n\n        this.nodes[ row_index ].columns[ col_index ][ key ] = value;\n    }\n\n    /**\n     * setPotentialNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialNodeClasses(row_index, col_index, key, value) {\n\n        this.setPotentialChildNodeClasses(row_index, col_index, key, value);\n        this.setPotentialParentNodeClasses(row_index, col_index, key, value);\n    }\n\n    /**\n     * setPotentialChildNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialChildNodeClasses(row_index, col_index, key, value) {\n\n        // if child row is not out of bounds\n        if ((row_index + 1) < (this.nodes.length)) {\n\n            // loop child row columns\n            _.forEach(this.nodes[ row_index + 1 ].columns, (child_col, child_col_index) => {\n\n                // if child node is potential then update class property\n                if (this.isNodePotential([ col_index, row_index ], [ child_col_index, row_index + 1 ])) {\n                    child_col[ key ] = value;\n                }\n            });\n        }\n    }\n\n    /**\n     * setPotentialParentNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialParentNodeClasses(row_index, col_index, key, value) {\n\n        if (row_index > 0) {\n\n            // loop parent node columns\n            _.forEach(this.nodes[ row_index - 1 ].columns, (parent_col, parent_col_index) => {\n\n                // if parent node is potential then update class property\n                if (this.isNodePotential([ col_index, row_index ], [ parent_col_index, row_index - 1 ])) {\n                    parent_col[key] = value;\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // viewport\n    //-----------------------------\n\n    /**\n     * setViewport\n     *\n     * @param cols\n     * @param rows\n     */\n    setViewport(cols, rows) {\n\n        let total_item_width = this.config.node_width + this.config.col_spacing;\n        let total_item_height = this.config.node_height + this.config.row_spacing;\n\n        this.viewport_width = total_item_width * cols;\n        this.viewport_height = total_item_height * rows;\n\n        this.viewport_style = {\n            'background-color': \"#ccc\",\n            'min-width': this.viewport_width + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.wrapper_style = {\n            'max-width': (this.viewport_width + this.config.max_viewport_width_increase) + \"px\",\n            'min-width': this.viewport_width + \"px\",\n            'max-height': (this.viewport_height + (this.config.max_viewport_height_increase * rows)) + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.viewport_viewbox = \" 0 0 \" + this.viewport_width + \" \" + this.viewport_height;\n    }\n\n    /**\n     * checkViewport\n     *\n     * @param col_index\n     * @param row_index\n     */\n    checkViewport(col_index, row_index) {\n\n        let should_update_viewport = false;\n\n        // row bounds check\n        if (row_index >= this.grid_row_count) {\n\n            // increase rowspan\n            this.grid_row_count++;\n            should_update_viewport = true;\n        }\n\n        // col bounds check\n        if (col_index >= this.grid_col_count) {\n\n            // increase colspan\n            this.grid_col_count++;\n            should_update_viewport = true;\n\n            // add bg grid col\n            this.addBgGridCol(this.grid_col_count - 1);\n        }\n\n        // set viewport\n        if (should_update_viewport) {\n            this.setViewport(this.grid_col_count, this.grid_row_count);\n        }\n    }\n\n    //-----------------------------\n    // coords\n    //-----------------------------\n\n    /**\n     * calculateColX\n     *\n     * @param index\n     */\n    calculateColX(index) {\n        if (index === 0) {\n            return 0;\n        }\n        let first_col_width = this.config.node_width + (this.config.col_spacing / 2);\n        let col_width = this.config.node_width + (this.config.col_spacing);\n        return first_col_width + ((index - 1) * col_width);\n    }\n\n    /**\n     * calculateColWidth\n     *\n     * @param index\n     */\n    calculateColWidth(index) {\n        let total_item_width = index === 0 ? this.config.node_width + (this.config.col_spacing / 2) : this.config.node_width + this.config.col_spacing;\n        return total_item_width;\n    }\n\n    /**\n     * calculateRowY\n     *\n     * @param index\n     */\n    calculateRowY(index) {\n        let row_height = this.config.node_height + this.config.row_spacing;\n        return index * row_height;\n    }\n\n    /**\n     * calculateRowHeight\n     *\n     * @param index\n     */\n    calculateRowHeight() {\n        return this.config.node_height + this.config.row_spacing;\n    }\n\n    //-----------------------------\n    // drawing\n    //-----------------------------\n\n    /**\n     * addLine\n     *\n     * @param source_coords [col, row]\n     * @param target_coords [col, row]\n     * @param connected\n     */\n    addLine(source_coords, target_coords, connected) {\n\n        // check bounds\n        if (target_coords[1] >= this.nodes.length) {\n            return false;\n        }\n\n        // get coords\n        let source_lock_coords = NodeUtils.getNodeCoords(source_coords[1], source_coords[0], NODE_BOTTOM, this.config);\n        let target_lock_coords = NodeUtils.getNodeCoords(target_coords[1], target_coords[0], NODE_TOP, this.config);\n\n        // add line properties\n        this.nodes[ source_coords[1] ].columns[ source_coords[0] ].lines.push({\n            connected: !_.isUndefined(connected) ? connected : false,\n            from: source_coords,\n            to: target_coords,\n            x1: source_lock_coords[0],\n            y1: source_lock_coords[1],\n            x2: target_lock_coords[0],\n            y2: target_lock_coords[1],\n            init: true\n        });\n\n        // // add line properties\n        // let _line = new AngularSvgNodeLine({\n        //     connected: !_.isUndefined(connected) ? connected : false,\n        //     from: source_coords,\n        //     to: target_coords,\n        //     x1: source_lock_coords[0],\n        //     y1: source_lock_coords[1],\n        //     x2: target_lock_coords[0],\n        //     y2: target_lock_coords[1],\n        //     should_animate: true\n        // });\n        //\n        // this.nodes[ source_coords[1] ].columns[ source_coords[0] ].lines.push(_line);\n\n        if (connected) {\n            // update data\n            // this.state[source_coords[1]].columns[source_coords[0]].connections.push(target_coords[0]);\n        }\n    }\n\n    /**\n     * updateLineTarget\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    updateLineTarget(source_coords, target_coords) {\n\n        // get target lock coords\n        let target_lock_coords = NodeUtils.getNodeCoords(target_coords[1], target_coords[0], NODE_TOP, this.config);\n\n        // find line\n        _.forEach(this.nodes[ source_coords[1] ].columns[ source_coords[0] ].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.to = target_coords;\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeLine\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param set_as_busy\n     */\n    removeLine(source_coords, target_coords, set_as_busy) {\n\n        if (set_as_busy) {\n            this.is_connection_change_busy = true;\n        }\n\n        // get target lock coords\n        let target_lock_coords = NodeUtils.getNodeCoords(source_coords[1], source_coords[0], NODE_BOTTOM, this.config);\n\n        // find line\n        _.forEach(this.nodes[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                let node = this.nodes[ target_coords[1] ].columns[ target_coords[0] ];\n                let node_has_connected_parents = this.doesNodeHaveConnectedParents(target_coords[1], target_coords[0], source_coords);\n\n                // if node has no lines & has no parent connections\n                if (node.lines.length === 0 && !node_has_connected_parents) {\n                    // set as not connected\n                    this.setAsNotConnectedNode(target_coords);\n                }\n\n                // if node has no parent connections\n                let node_has_active_parents = this.doesNodeHaveActiveParents(target_coords[1], target_coords[0], source_coords);\n\n                if (!node_has_active_parents) {\n\n                    // deactivate node\n                    this.deactivateNode(target_coords[1], target_coords[0]);\n                }\n\n                // set line properties\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.previous_to = line.to; // TODO: this feels a bit hacky\n                line.to = [ source_coords[0], source_coords[1] ];\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeUnconnectedLines\n     *\n     * @param selection\n     */\n    removeUnconnectedLines(selection) {\n        _.forEach(this.nodes[ selection[0][1] ].columns[ selection[0][0] ].lines, (line) => {\n            if (!line.connected) {\n                this.removeLine(this.selection[0], this.selection[1]);\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedLines\n     *\n     * @param selection\n     */\n    setAsConnectedLines(selection) {\n\n        _.forEach(this.nodes[ selection[0][1] ].columns[ selection[0][0] ].lines, (line, line_index) => {\n            if (!line.connected) {\n\n                // setAsConnected line\n                line.connected = true;\n\n                // setAsConnected nodes\n                this.setAsConnectedNode(line.from);\n                this.setAsConnectedNode(line.to);\n\n                // external callback\n                if (!_.isUndefined(this.onNodeConnectionChangeCallback)) {\n\n                    // so that onNodeDeselection can decide whether to call as well\n                    this.was_connection_change_called = true;\n\n                    let _params = {\n                        source_row_index: line.from[1],\n                        source_col_index: line.from[0],\n                        target_row_index: line.to[1],\n                        target_col_index: line.to[0],\n                        is_connected: true\n                    };\n                    this.onNodeConnectionChangeCallback(_params);\n                }\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedNode\n     *\n     * @param coords\n     */\n    setAsConnectedNode(coords) {\n        this.nodes[ coords[1] ].columns[ coords[0] ].connected = true;\n    }\n\n    /**\n     * setAsNotConnectedNode\n     *\n     * @param coords\n     */\n    setAsNotConnectedNode(coords) {\n        this.nodes[ coords[1] ].columns[ coords[0] ].connected = false;\n    }\n\n    /**\n     * addNode\n     *\n     * @param row_index\n     * @param col_index\n     * @param label\n     * @param connections\n     * @param data\n     * @returns {boolean}\n     */\n    addNode(row_index, col_index, label, connections, data) {\n\n        // create row if it doesn't exist\n        if (row_index === this.nodes.length) {\n            this.nodes.push({columns: []});\n        }\n\n        // if node already exists (control) then remove and re-add after node\n        let removed_node;\n\n        if (!_.isUndefined(this.nodes[ row_index ].columns[ col_index ])) {\n            removed_node = this.nodes[ row_index ].columns.splice(col_index, 1);\n        }\n\n        // get top left coords\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n\n        // lines\n        let node_lines = [];\n        let line_source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n        _.forEach(connections, (line_target_col_index) => {\n\n            let line_target_coords = [ line_target_col_index, row_index + 1 ];\n            let line_target_lock_coords = NodeUtils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n            node_lines.push({\n                connected: true,\n                from: [ col_index, row_index ],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set nodes as connected\n            this.nodes_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set node properties\n        let node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: label,\n            connected: node_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: node_lines,\n            selected: _.has(data, \"selected\") ? data.selected : false,\n            highlight: _.has(data, \"highlight\") ? data.highlight : false\n        };\n\n        // if this node is selected\n        if (node.selected) {\n\n            // ... and there is another node already selected\n            // ... then remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = node.row_index;\n            this.highlight_selected_node.col_index = node.col_index;\n        }\n\n        // add node\n        this.nodes[ row_index ].columns.push(node);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n        // replace removed node\n        if (!_.isUndefined(removed_node)) {\n            this.addControlNode(removed_node[0].row_index);\n        }\n\n        this.new_node = { row_index, col_index };\n\n        // highlight node\n        // ... if configured to do so\n        // ... and not initialising\n\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_ADD) && !this.is_initialising) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[ row_index ].columns[ col_index ].selected = true;\n        }\n\n        // external callback\n        // ... if not initialising\n        if (!_.isUndefined(this.onNodeAddedCallback) && !this.is_initialising) {\n            this.onNodeAddedCallback({ row_index, col_index });\n        }\n    }\n\n    /**\n     * updateNode\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     * @param lines\n     */\n    updateNode(row_index, col_index, label, lines = []) {\n\n        // update label\n        if (!_.isUndefined(label) && this.nodes[ row_index ].columns[ col_index ].label !== label) {\n            this.nodes[ row_index ].columns[ col_index ].label = label;\n        }\n\n        // update lines\n        if (!_.isUndefined(lines)) {\n\n            let line_source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n            _.forEach(lines, (line_target_col_index) => {\n\n                let line_target_coords = [ line_target_col_index, row_index + 1 ];\n                let line_target_lock_coords     = NodeUtils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n                // if already has this connection\n                if (_.includes(_.map(this.nodes[ row_index ].columns[ col_index ].lines, (line) => line.to[0]), line_target_col_index)) {\n                    return;\n                }\n\n                this.nodes[ row_index ].columns[ col_index ].lines.push({\n                    connected: true,\n                    from: [ col_index, row_index ],\n                    to: line_target_coords,\n                    x1: line_source_lock_coords[0],\n                    y1: line_source_lock_coords[1],\n                    x2: line_target_lock_coords[0],\n                    y2: line_target_lock_coords[1]\n                });\n\n                this.setNodeClass(row_index, col_index, 'connected', true);\n\n                // set nodes as connected\n                this.nodes_waiting_for_connection.push(line_target_coords);\n            });\n        }\n    }\n\n    /**\n     * removeNode\n     *\n     * @param row_index\n     * @param col_index\n     */\n    removeNode(row_index, col_index) {\n\n        // remove lines\n        let _set_as_busy = false;\n        _.forEach(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n            this.removeLine(line.from, line.to, _set_as_busy);\n        });\n\n        // remove node\n        this.nodes[ row_index ].columns.splice(col_index, 1);\n\n        // update data\n        // this.state[ row_index ].columns.splice(col_index, 1);\n\n        // update siblings\n        for (let i = col_index; i < (this.nodes[ row_index ].columns.length); i++) {\n            this.updateNodeAfterSiblingAddedOrRemoved(row_index, i);\n\n            // if not last column (control)\n            if (i < this.nodes[ row_index ].columns.length - 1) {\n                // TODO: why not update nodes???\n                // this.state[ row_index ].columns[i].data.ui_column_index = i;\n                // this.state[ row_index ].columns[i].data.ui_row_index = row_index;\n            }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            let parent_row_index = row_index - 1;\n            let remove_lines = [];\n\n            _.forEach(this.nodes[parent_row_index].columns, (column, parent_col_index) => {\n                _.forEach(column.lines, (line, line_index) => {\n\n                    // if parent connects to this node\n                    if (_.isEqual(line.to, [col_index, row_index])) {\n\n                        // column.lines.splice(line_index, 1);\n\n                        // mark lines for removal\n                        remove_lines.push({\n                            row_index: parent_row_index,\n                            col_index: parent_col_index,\n                            line_index: line_index\n                        });\n\n                        // update data\n                        //this.state[parent_row_index].columns[parent_col_index].connections.splice(line_index, 1);\n\n                        // if parent no longer has any lines\n                        if (column.lines.length === 0) {\n                            this.setAsNotConnectedNode([ parent_col_index, parent_row_index ]);\n                        }\n                    }\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] > col_index) {\n\n                        // update lines target\n                        let new_line_to = [line.to[0] - 1, line.to[1]];\n\n                        // get target lock coords\n                        let target_lock_coords = NodeUtils.getNodeCoords(new_line_to[1], new_line_to[0], NODE_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n\n            // remove lines\n            _.map(remove_lines, (data) => {\n                this.nodes[data.row_index].columns[data.col_index].lines.splice(data.line_index, 1);\n            });\n        }\n\n        // update children\n        // TODO: can we use node???\n        if (row_index !== this.nodes.length - 1) {\n            let children_row_index = row_index + 1;\n            _.forEach(this.nodes[children_row_index].columns, (column, children_col_index) => {\n\n                // if  node has no parent connections\n                if (!this.doesNodeHaveConnectedParents(children_row_index, children_col_index)) {\n                    this.setAsNotConnectedNode([ children_col_index, children_row_index ]);\n                }\n            });\n        }\n    }\n\n    /**\n     * insertNode\n     *\n     * @param row_index\n     * @param col_index\n     * @param label\n     * @param joins\n     * @returns {boolean}\n     */\n    insertNode(row_index, col_index, label, joins) {\n\n        // get top left coords\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n\n        // lines\n        let node_lines = [];\n        let line_source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n        _.forEach(joins, (line_target_col_index) => {\n\n            let line_target_coords = [line_target_col_index, row_index + 1];\n            let line_target_lock_coords = NodeUtils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n            node_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set nodes as connected\n            this.nodes_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set node properties\n        let node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: label,\n            connected: node_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: node_lines\n        };\n\n        // TODO: add highlight and selected\n\n        // insert node\n        this.nodes[ row_index ].columns.splice(col_index, 0, node);\n\n        // update data\n        //this.state[ row_index ].columns.splice(col_index, 0, data);\n\n        // update siblings\n        for (let i = col_index + 1; i < (this.nodes[ row_index ].columns.length); i++) {\n\n            this.updateNodeAfterSiblingAddedOrRemoved(row_index, i);\n\n            // if not last column (control)\n            // if (i < this.nodes[ row_index ].columns.length - 1) {\n            //     this.state[ row_index ].columns[i].data.ui_column_index = i;\n            //     this.state[ row_index ].columns[i].data.ui_row_index = row_index;\n            // }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            let parent_row_index = row_index - 1;\n            _.forEach(this.nodes[parent_row_index].columns, (column) => {\n                _.forEach(column.lines, (line) => {\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] >= col_index) {\n\n                        // update lines target\n                        let new_line_to = [line.to[0] + 1, line.to[1]];\n\n                        // get target lock coords\n                        let target_lock_coords = NodeUtils.getNodeCoords(new_line_to[1], new_line_to[0], NODE_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * updateNodeAfterSiblingAddedOrRemoved\n     *\n     * @param {Integer}    row_index\n     * @param {Integer}    col_index\n     */\n    updateNodeAfterSiblingAddedOrRemoved(row_index, col_index) {\n\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        let center_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // update node\n\n        this.nodes[ row_index ].columns[ col_index ].col_index = col_index;\n        this.nodes[ row_index ].columns[ col_index ].coords = top_left_coords;\n        this.nodes[ row_index ].columns[ col_index ].x = top_left_coords[0];\n        this.nodes[ row_index ].columns[ col_index ].y = top_left_coords[1];\n\n        // update labels\n        // last node has different label position\n        if (col_index === (this.nodes[ row_index ].columns.length - 1)) {\n            this.nodes[ row_index ].columns[ col_index ].label_x = center_coords[0];\n            this.nodes[ row_index ].columns[ col_index ].label_y = center_coords[1];\n        } else {\n            this.nodes[ row_index ].columns[ col_index ].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.nodes[ row_index ].columns[ col_index ].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n\n            // get target lock coords\n            let source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * updateNodeAfterChildAddedOrRemoved\n     *\n     * @param {Integer}    row_index\n     * @param {Integer}    col_index\n     */\n    updateNodeAfterChildAddedOrRemoved(row_index, col_index) {\n\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        let center_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // update node\n\n        this.nodes[ row_index ].columns[ col_index ].col_index = col_index;\n        this.nodes[ row_index ].columns[ col_index ].coords = top_left_coords;\n        this.nodes[ row_index ].columns[ col_index ].x = top_left_coords[0];\n        this.nodes[ row_index ].columns[ col_index ].y = top_left_coords[1];\n\n        // update labels\n        // last node has different label position\n        if (col_index === (this.nodes[ row_index ].columns.length - 1)) {\n            this.nodes[ row_index ].columns[ col_index ].label_x = center_coords[0];\n            this.nodes[ row_index ].columns[ col_index ].label_y = center_coords[1];\n        } else {\n            this.nodes[ row_index ].columns[ col_index ].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.nodes[ row_index ].columns[ col_index ].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n\n            // get target lock coords\n            let source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(row_index, col_index);\n    }\n\n    /**\n     * addControlNode\n     *\n     * @param {Integer}    row_index\n     */\n    addControlNode(row_index) {\n\n        // create row if it doesn't exist\n        if (row_index === this.nodes.length) {\n            this.nodes.push({columns: []});\n        }\n\n        // validate row index\n        if (row_index >= this.nodes.length) {\n            throw new Error(\"Invalid row index\");\n        }\n\n        let col_index = this.nodes[ row_index ].columns.length;\n\n        // get top left coords\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        let center_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // set node properties\n        let node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: center_coords[0],\n            label_y: center_coords[1],\n            label: \"+\",\n            connected: false,\n            control: true,\n            row_index: row_index,\n            col_index: col_index,\n            lines: []\n        };\n\n        // add node\n        this.nodes[ row_index ].columns.push(node);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n    }\n\n    /**\n     * addBgGridCol\n     *\n     * @param {Integer}    index\n     */\n    addBgGridCol(index) {\n\n        this.bg_col_grid.push({\n            index: index,\n            x: this.calculateColX(index),\n            width: this.calculateColWidth(index)\n        });\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // update\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * update\n     *\n     * @param data\n     * @param column_property_name\n     */\n    update(data, column_property_name) {\n\n        // add controls\n        _.forEach(data, (row, row_index) => {\n\n            // ... if row index exceeds or equals current UI rows\n            if (row_index >= this.nodes.length) {\n                this.addControlNode(row_index);\n            }\n        });\n\n        // add nodes\n        _.forEach(data, (row, row_index) => {\n            _.forEach(row[column_property_name], (col, col_index) => {\n\n                // update node\n                this.updateNode(row_index, col_index, col.label);\n\n                // ... if column index exceeds or equals current UI cols (excluding control)\n                if (col_index >= this.nodes[ row_index ].columns.length - 1) {\n                    let label = _.has(col, 'label') ? col.label : \"\";\n                    let lines = _.has(col, 'connections') ? col.connections : [];\n                    this.addNode(row_index, col_index, label, lines);\n                }\n            });\n        });\n\n        // set viewport\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        // check active\n        this.checkActive();\n    }\n}\n\nAngularSvgNodesController.$inject = [ '$scope' ];"],"sourceRoot":"src/app/*.js"}