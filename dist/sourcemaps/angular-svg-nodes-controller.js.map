{"version":3,"sources":["angular-svg-nodes-controller.js"],"names":[],"mappings":"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","file":"angular-svg-nodes-controller.js","sourcesContent":["// local: constants\nimport {\n    NODE_TOP_LEFT,\n    NODE_TOP,\n    NODE_CENTER,\n    NODE_BOTTOM,\n    HIGHLIGHT_NODE_ON_SELECT,\n    HIGHLIGHT_NODE_ON_DESELECT,\n    HIGHLIGHT_NODE_ON_ADD,\n    DEFAULT_NEW_NODE_LABEL,\n    DEFAULT_HIGHLIGHT_NODE_ON,\n    DEFAULT_INITIAL_GRID_COLS,\n    DEFAULT_INITIAL_GRID_ROWS,\n    DEFAULT_NODE_WIDTH,\n    DEFAULT_NODE_HEIGHT,\n    DEFAULT_COL_SPACING,\n    DEFAULT_ROW_SPACING,\n    DEFAULT_LABEL_SPACING,\n    DEFAULT_DISABLE_CONTROL_NODES,\n    DEFAULT_MAX_VIEWPORT_WIDTH_INCREASE,\n    DEFAULT_MAX_VIEWPORT_HEIGHT_INCREASE\n} from \"./angular-svg-nodes-settings\";\n\n// local: services\nimport * as Utils from './angular-svg-nodes-utils';\nimport * as ApiValidator from './api/api-validator';\n\nexport default class AngularSvgNodesController {\n\n    constructor($s) {\n\n        this.$s = $s;\n\n        //-----------------------------\n        // directives vars\n        //-----------------------------\n        //\n        // this.initial_state\n        // this.api\n        //\n        //-----------------------------\n\n        if (_.isUndefined(this.api)) {\n            this.api = {};\n        }\n\n        //-----------------------------\n        // state\n        //-----------------------------\n\n        this.state = [];\n\n        //-----------------------------\n        // config\n        //-----------------------------\n\n        // TODO: validate highlight node on array (remove invalid options)\n\n        this.config = {\n            new_node_label: !_.isUndefined(this.config_new_node_label) ? this.config_new_node_label : DEFAULT_NEW_NODE_LABEL,\n            initial_grid_cols: !_.isUndefined(this.config_initial_grid_cols) ? this.config_initial_grid_cols : DEFAULT_INITIAL_GRID_COLS,\n            initial_grid_rows: !_.isUndefined(this.config_initial_grid_rows) ? this.config_initial_grid_rows : DEFAULT_INITIAL_GRID_ROWS,\n            highlight_node_on: !_.isUndefined(this.config_highlight_node_on) ? this.config_highlight_node_on : DEFAULT_HIGHLIGHT_NODE_ON,\n            node_width: !_.isUndefined(this.config_node_width) ? this.config_node_width : DEFAULT_NODE_WIDTH,\n            node_height: !_.isUndefined(this.config_node_height) ? this.config_node_height : DEFAULT_NODE_HEIGHT,\n            col_spacing: !_.isUndefined(this.config_col_spacing) ? this.config_col_spacing : DEFAULT_COL_SPACING,\n            row_spacing: !_.isUndefined(this.config_row_spacing) ? this.config_row_spacing : DEFAULT_ROW_SPACING,\n            label_spacing: !_.isUndefined(this.config_label_spacing) ? this.config_label_spacing : DEFAULT_LABEL_SPACING,\n            disable_control_nodes: !_.isUndefined(this.config_disable_control_nodes) ? this.config_disable_control_nodes : DEFAULT_DISABLE_CONTROL_NODES,\n            max_viewport_width_increase: !_.isUndefined(this.config_max_viewport_width_increase) ? this.config_max_viewport_width_increase : DEFAULT_MAX_VIEWPORT_WIDTH_INCREASE,\n            max_viewport_height_increase: !_.isUndefined(this.config_max_viewport_height_increase) ? this.config_max_viewport_height_increase : DEFAULT_MAX_VIEWPORT_HEIGHT_INCREASE\n        };\n\n        //-----------------------------\n        // control\n        //-----------------------------\n\n        this.is_initialising = false;\n\n        // allows onNodeDeselection to decide whether or not to fire external callback straight after onConnectionChange callback was fired\n        this.was_connection_change_called = false;\n        this.is_connection_change_busy = false;\n\n        // an array of node coords that will be set as connected on teh line\n        this.nodes_waiting_for_connection = [];\n\n        // parent coordinates (for reference)\n        this.parent_coords = [];\n\n        // view coordinates (for reference)\n        this.coords = [];\n\n        // view element data\n        this.nodes = [];\n\n        // array for bg grid\n        this.bg_col_grid = [];\n        this.bg_col_grid_hover_index = null;\n\n        // grid dimmensions\n        this.grid_col_count = this.config.initial_grid_cols;\n        this.grid_row_count = this.config.initial_grid_rows;\n        this.label_width = this.config.node_width - (this.config.label_spacing * 2);\n        this.label_height = this.config.node_height - (this.config.label_spacing * 2);\n\n        // viewport style & bounds\n        this.wrapper_style = \"\";\n        this.viewport_style = \"\";\n        this.viewport_width = 0;\n        this.viewport_height = 0;\n        this.viewport_viewbox = \"\";\n\n        // node selections\n        this.selection = [];\n        this.source_exit_side = null;\n\n        // active node\n        this.selected_node = [];\n\n        // highlighted selected node\n        this.highlight_selected_node = {};\n\n        this.new_node = {};\n\n        ////////////////////////////////////////////////\n        //\n        // watchers\n        //\n        ////////////////////////////////////////////////\n\n        this.$s.$watch('AngularSvgNodes.selection', (newValue, oldValue) => {\n\n            if (_.isUndefined(newValue)) {\n                return;\n            }\n\n            // two selected & target is child of source\n            if (newValue.length === 2 && newValue[1][1] > newValue[0][1]) {\n\n                // new target selection\n                if (newValue.length > oldValue.length) {\n\n                    // add line\n                    this.addLine(this.selection[0], this.selection[1]);\n                }\n\n                // updated target selection\n                else {\n\n                    // update line\n                    this.updateLineTarget(this.selection[0], this.selection[1]);\n                }\n            }\n        }, true);\n\n        this.$s.$watch('AngularSvgNodes.initial_state', (newValue, oldValue) => {\n\n            this.init();\n        });\n\n        ////////////////////////////////////////////////\n        //\n        // api\n        //\n        ////////////////////////////////////////////////\n\n        /**\n         * addRow\n         *\n         * @param label\n         */\n        this.api.addRow = (label = \"\") => {\n\n            let _row_index = this.nodes.length;\n            let _col_index = 0;\n\n            this.addNode(_col_index, _row_index, label, []);\n            this.addControl(_row_index);\n        };\n\n        /**\n         * removeNode\n         *\n         * @param _row_index\n         * @param _col_index\n         */\n        this.api.removeNode = (row_index, col_index) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.removeNode(col_index, row_index);\n        };\n\n        /**\n         * insertNode\n         *\n         * @param row_index\n         * @param col_index\n         * @param label\n         * @param connections\n         */\n        this.api.insertNode = (row_index, col_index, label, connections) => {\n\n            if (!ApiValidator.areApiCoordsValidForInsert(this.nodes, row_index, col_index)) {\n                return;\n            }\n            if (!ApiValidator.areApiConnectionsValid(this.nodes, row_index - 1, connections)) {\n                return;\n            }\n\n            this.insertNode(row_index, col_index, label, connections);\n        };\n\n        /**\n         * updateNodeConnections\n         *\n         * @param row_index\n         * @param col_index\n         * @param connections\n         */\n        this.api.updateNodeConnections = (row_index, col_index, connections) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n            if (!ApiValidator.areApiConnectionsValid(this.nodes, row_index, connections)) {\n                return;\n            }\n\n            let _label = this.nodes[row_index].columns[col_index].label;\n            let _lines = _.map(this.nodes[row_index].columns[col_index].lines, (line) => {\n                return _.has(line, 'to') ? line.to[0] : line;\n            });\n            let _connections = _.uniq([..._lines, ...connections]);\n\n            this.updateNode(row_index, col_index, _label, _connections);\n        };\n\n        /**\n         * setNodeLabel\n         *\n         * @param row_index\n         * @param col_index\n         * @param label\n         */\n        this.api.setNodeLabel = (row_index, col_index, label) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.updateNode(row_index, col_index, label);\n        };\n\n        /**\n         * setNodeHighlight\n         *\n         * @param row_index\n         * @param col_index\n         * @param value\n         */\n        this.api.setNodeHighlight = (row_index, col_index, value) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.nodes[row_index].columns[col_index].highlight = value;\n        };\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // init\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * init\n     */\n    init() {\n\n        this.is_initialising = true;\n\n        // resets\n        this.nodes = [];\n\n        let _column_property_name = 'columns';\n        let _data = !_.isUndefined(this.initial_state) ?  this.initial_state : [];\n\n        // add placeholders\n        for (var row_index = 0; row_index < this.config.initial_grid_rows; row_index++) {\n\n            // add data placeholder\n            if (row_index >= _data.length) {\n                _data.push({columns: []});\n            }\n        }\n\n        // add nodes\n        _.forEach(_data, (row, row_index) => {\n\n            _.forEach(row[ _column_property_name ], (col, col_index) => {\n\n                this.addNode(row_index, col_index, col.label, col.join, col);\n            });\n\n            this.addControl(row_index);\n        });\n\n        // add bg_col_grid array\n        _.map(new Array(this.grid_col_count), (col, index) => {\n            this.addBgGridCol(index);\n        });\n\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        this.checkActive();\n\n        this.update(_data, _column_property_name);\n\n        this.is_initialising = false;\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // handlers\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // general\n    //-----------------------------\n\n    /**\n     * onNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeSelect(col_index, row_index) {\n\n        // if control\n        if (this.nodes[row_index].columns[col_index].control) {\n            if (!this.config.disable_control_nodes) {\n                this.onControlNodeSelect(col_index, row_index);\n            }\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeSelect(col_index, row_index);\n\n        // highlight node\n        // ... if configured to do so\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_SELECT)) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[row_index].columns[col_index].selected = true;\n        }\n\n        // external callback\n        if (!_.isUndefined(this.onNodeSelectionCallback)) {\n            this.onNodeSelectionCallback({ col_index, row_index });\n        }\n    }\n\n    /**\n     * onNodeDeselect\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeDeselect(col_index, row_index) {\n\n        // if control\n        if (this.nodes[row_index].columns[col_index].control) {\n            return false;\n        }\n\n        // if node\n        this.onNodeNodeDeselect(col_index, row_index);\n\n        let _is_new_node = _.isEqual(this.new_node, {row_index, col_index});\n\n        // highlight node\n        // ... if configured to do so\n        // ... and node is not new node (just added)\n        // ... and connection change callback was not just called\n        // ... and connection change is not busy (happens on line remove)\n\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_DESELECT) && !_is_new_node && !this.was_connection_change_called && !this.is_connection_change_busy) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[row_index].columns[col_index].selected = true;\n        }\n\n        // external callback\n        // ... if connection change callback was not just called\n        // ... and connection change is not busy (happens on line remove)\n\n        if (!_.isUndefined(this.onNodeDeselectionCallback) && !_is_new_node && !this.was_connection_change_called && !this.is_connection_change_busy) {\n            this.onNodeDeselectionCallback({ col_index, row_index });\n        }\n\n        this.new_node = {}; // reset\n        this.was_connection_change_called = false; // reset\n    }\n\n    /**\n     * onNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onNodeMouseOver(col_index, row_index) {\n\n        // if control\n        if (this.nodes[row_index].columns[col_index].control) {\n            this.onControlNodeMouseOver(col_index, row_index);\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeMouseOver(col_index, row_index);\n    }\n\n    /**\n     * onNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeMouseOut(row_index, col_index, exit_side) {\n\n        // if control\n        if (this.nodes[row_index].columns[col_index].control) {\n            this.onControlNodeMouseOut(col_index, row_index);\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeMouseOut(row_index, col_index, exit_side);\n    }\n\n    //-------------------------------------------------\n    // control node handlers\n    //-------------------------------------------------\n\n    /**\n     * onControlNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onControlNodeSelect(col_index, row_index) {\n\n        let _label = _.isFunction(this.config.new_node_label) ? this.config.new_node_label(row_index, col_index) : this.config.new_node_label;\n\n        this.addNode(row_index, col_index, _label, []);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onControlNodeMouseOver(col_index, row_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(row_index, col_index, 'control_hover', true);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @returns {boolean}\n     */\n    onControlNodeMouseOut(col_index, row_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(row_index, col_index, 'control_hover', false);\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // node node handlers\n    //-------------------------------------------------\n\n    /**\n     * onNodeNodeSelect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onNodeNodeSelect(col_index, row_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        this.setNodeClass(row_index, col_index, 'source_hover', false);\n        this.setNodeClass(row_index, col_index, 'source', true);\n        this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', false);\n        this.setPotentialNodeClasses(row_index, col_index, 'potential_target', true);\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // set selection\n        this.selection = [[col_index, row_index]];\n        this.selected_node = [col_index, row_index];\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onNodeNodeDeselect\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onNodeNodeDeselect(col_index, row_index) {\n\n        // reset last exit side\n        this.source_exit_side = null;\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if one selection\n        if (this.selection.length === 1) {\n\n            // if deselecting on current source\n            if (_.isEqual(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(row_index, col_index, 'source', false);\n                this.setNodeClass(row_index, col_index, 'source_hover', true);\n                this.setPotentialNodeClasses(row_index, col_index, 'potential_target', false);\n                this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', true);\n            }\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if deselecting on current target (& is potential ?)\n            if (_.isEqual(this.selection[1], [col_index, row_index])) {\n\n                this.setNodeClass(row_index, col_index, 'target', false);\n\n                // if  node has no parent connections\n                if (!this.doesNodeHaveConnectedParents(col_index, row_index)) {\n                    this.setPotentialNodeClasses(row_index, col_index, 'potential_target', false);\n                }\n\n                // check active\n                this.checkActive();\n            }\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // if deselecting on current target & is potential\n            if (_.isEqual(this.selection[1], [col_index, row_index]) && this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                var is_target_parent = this.selection[0][1] > row_index;\n\n                // if target is parent then remove line\n                if (is_target_parent) {\n                    this.removeLine(this.selection[1], this.selection[0]);\n                }\n\n                // if target is child then setAsConnected line\n                else {\n                    this.setAsConnectedLines(this.selection, \"A\");\n\n                    // check active\n                    this.checkActive();\n                }\n            }\n        }\n    }\n\n    /**\n     * onNodeNodeMouseOver\n     *\n     * @param col_index\n     * @param row_index\n     */\n    onNodeNodeMouseOver(col_index, row_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selection\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(row_index, col_index, 'source_hover', true);\n            this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', true);\n        }\n\n        // if two selections\n        if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(row_index, col_index, 'potential_target', false);\n                this.setNodeClass(row_index, col_index, 'target', true);\n                this.setLineClass(this.selection[0], [col_index, row_index], 'target', true);\n            }\n        }\n\n        // if col changed\n        if (this.bg_col_grid_hover_index !== col_index) {\n\n            //this.bg_col_grid_hover_index = col_index;\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // if 2 selections and new col index is potential\n            //if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [col_index, this.selection[1][1]])) {\n            //    this.selection[1][0] = col_index;\n            //}\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onNodeNodeMouseOut\n     *\n     * @param col_index\n     * @param row_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeNodeMouseOut(row_index, col_index, exit_side) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selections\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(row_index, col_index, 'source_hover', false);\n            this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', false);\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [col_index, row_index])) {\n\n                this.setNodeClass(row_index, col_index, 'target', false);\n                this.setNodeClass(row_index, col_index, 'potential_target', true);\n                this.setLineClass(this.selection[0], [col_index, row_index], 'target', false);\n            }\n        }\n\n        // if this is source selection & source_exit_side not yet set\n        if (_.isEqual(this.selection[0], [col_index, row_index]) && _.isNull(this.source_exit_side)) {\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                // remove 'potential child' class from potential children\n                this.setPotentialChildNodeClasses(row_index, col_index, 'potential_target', false);\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                // remove 'potential child' class from potential parent\n                this.setPotentialParentNodeClasses(row_index, col_index, 'potential_target', false);\n            }\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if one selection one selected\n        if (this.selection.length === 1) {\n\n            // if this is source selection\n            if (_.isEqual(this.selection[0], [col_index, row_index])) {\n\n                // update source exit side\n                this.source_exit_side = exit_side;\n            }\n\n            var target_coords;\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                target_coords = [this.bg_col_grid_hover_index, row_index - 1];\n\n                // if target is potential\n                if (this.isNodePotential([col_index, row_index], target_coords)) {\n                    this.selection.push(target_coords);\n                }\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                var target_row_index = row_index + 1;\n                target_coords = [this.bg_col_grid_hover_index, target_row_index];\n\n                // if not spanning more than one row && target is potential\n                if (Math.abs(this.selection[0][1] - target_row_index) <= 1 && this.isNodePotential([col_index, row_index], target_coords)) {\n\n                    this.selection.push(target_coords);\n                }\n\n            }\n        }\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // grid handlers\n    //-------------------------------------------------\n\n    /**\n     * onRootDeselect\n     */\n    onRootDeselect() {\n\n        // reset source_exit_side\n        this.source_exit_side = null;\n\n        // nothing to do if there are no selections\n        if (this.selection.length === 0) {\n            return true;\n        }\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if selections\n        if (this.selection.length > 0) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // reset if there are not 2 selections\n        if (this.selection.length > 0) {\n            this.selection = [];\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBgColGridMouseOver\n     */\n    onBgColGridMouseOver(index) {\n\n        // do nothing if unchanged\n        if (this.bg_col_grid_hover_index === index) {\n            return true;\n        }\n\n        this.bg_col_grid_hover_index = index;\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            var target_coords = this.source_exit_side === 'top' ? [index, this.selection[0][1] - 1] : [index, this.selection[0][1] + 1];\n\n            // if target is potential\n            if (this.isNodePotential(this.selection[0], target_coords)) {\n                this.selection.push(target_coords);\n            }\n        }\n\n        // if 2 selections and new col index is potential\n        else if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [index, this.selection[1][1]])) {\n            this.selection[1][0] = index;\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onRootMouseLeave\n     *\n     * @param e\n     */\n    onRootMouseLeave() {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        // if 2 selections\n        else if (this.selection.length === 2) {\n\n            this.setNodeClass(this.selection[0][0], this.selection[0][1], 'source', false);\n            this.setNodeClass(this.selection[1][0], this.selection[1][1], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][0], this.selection[0][1], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        this.selection = [];\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // line handlers\n    //-------------------------------------------------\n\n    /**\n     * onLineRemoveComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineRemoveComplete(source_coords, target_coords, line_index) {\n\n        // update data\n        //this.state[source_coords[1]].columns[source_coords[0]].join.splice(line_index, 1);\n\n        // update nodes\n        var source = this.nodes[source_coords[1]].columns[source_coords[0]];\n\n        let _was_line_connected = source.lines[ line_index ].connected;\n\n        // delete line\n        source.lines.splice(line_index, 1);\n\n        // if source node has no more lines then setAsNotConnected\n        if (source.lines.length === 0) {\n\n            // if  node has no parent connections\n            if (!this.doesNodeHaveConnectedParents(source_coords[0], source_coords[1])) {\n                this.setAsNotConnectedNode([source_coords[0], source_coords[1]]);\n            }\n        }\n\n        // external callback\n        // ... if line was connected\n        // ... dotted temp line used for showing intended target is not connected, and it's removal should not trigger callback\n        if (!_.isUndefined(this.onNodeConnectionChangeCallback) && _was_line_connected) {\n\n            // don't need to set here because this happens after onNodeDeselection\n            // this.was_connection_change_called = true;\n\n            let _params = {\n                source_row_index: source_coords[1],\n                source_col_index: source_coords[0],\n                target_row_index: target_coords[1],\n                target_col_index: target_coords[0],\n                is_connected: false\n            };\n            this.onNodeConnectionChangeCallback(_params);\n        }\n\n        this.is_connection_change_busy = false;\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onLineDrawComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineDrawComplete(source_coords, target_coords) {\n\n        var is_node_waiting_for_connection = false;\n\n        _.forEach(this.nodes_waiting_for_connection, (node, index) => {\n            if (_.isEqual(node, target_coords)) {\n                is_node_waiting_for_connection = true;\n                this.nodes_waiting_for_connection.splice(index, 1);\n                return false;\n            }\n        });\n\n        if (is_node_waiting_for_connection) {\n\n            // connect node\n            this.setAsConnectedNode(target_coords);\n\n            // check active\n            this.checkActive();\n        }\n\n        this.$s.$apply();\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // utils\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // active check\n    //-----------------------------\n\n    /**\n     * checkActive\n     */\n    checkActive() {\n\n        if (this.nodes.length === 0) {\n            return false;\n        }\n\n        _.forEach(this.nodes[0].columns, (col, col_index) => {\n            if (col.lines.length > 0) {\n                this.activateNode(col_index, 0);\n            }\n        });\n    }\n\n    /**\n     * activateNode\n     *\n     * @param col_index\n     * @param row_index\n     */\n    activateNode(col_index, row_index) {\n\n        var node = this.nodes[row_index].columns[col_index];\n        node.active = true;\n\n        if (node.lines.length > 0) {\n\n            _.forEach(node.lines, (line) => {\n\n                // activate line\n                line.active = true;\n\n                // activate target node\n                this.activateNode(line.to[0], line.to[1]);\n            });\n        }\n    }\n\n    /**\n     * deactivateNode\n     *\n     * @param col_index\n     * @param row_index\n     */\n    deactivateNode(col_index, row_index) {\n\n        var node = this.nodes[row_index].columns[col_index];\n        node.active = false;\n\n        if (node.lines.length > 0) {\n            _.forEach(node.lines, (line) => {\n\n                // deactivate line\n                line.active = false;\n\n                var does_parent_have_active_nodes = this.doesNodeHaveActiveParents(line.to[0], line.to[1]);\n\n                // deactivate target node if no active parents\n                if (!does_parent_have_active_nodes) {\n                    this.deactivateNode(line.to[0], line.to[1]);\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // node potential\n    //-----------------------------\n\n    /**\n     * doesNodeHaveActiveParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveActiveParents(row_index, col_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        var result = false;\n        var parent_row_index = row_index - 1;\n        var parents = this.nodes[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n            _.forEach(parent.lines, (line) => {\n\n                // if parent coords are not equal to exclude coords\n                // ... and parent has a line to this node\n                // ... and parent is active\n                if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && _.isEqual(line.to, [col_index, row_index]) && parent.active) {\n                    result = true;\n                }\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * doesNodeHaveConnectedParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveConnectedParents(row_index, col_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        if (_.isUndefined(exclude_coords)) {\n            exclude_coords = [];\n        }\n\n        var result = false;\n        var parent_row_index = row_index - 1;\n        var parents = this.nodes[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n\n            // if parent coords are not equal to exclude coords and parent is potential (potential parent node is always connected)\n            if (!_.isEqual([parent_col_index, parent_row_index], exclude_coords) && this.isNodePotential([col_index, row_index], [parent_col_index, parent_row_index])) {\n\n                result = true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * isNodePotential\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    isNodePotential(source_coords, target_coords) {\n\n        // if not ready\n        if (_.isUndefined(this.nodes[target_coords[1]])) {\n            return false;\n        }\n        if (_.isUndefined(this.nodes[target_coords[1]].columns[target_coords[0]])) {\n            return false;\n        }\n\n        // refuse if control\n        if (this.nodes[target_coords[1]].columns[target_coords[0]].control) {\n            return false;\n        }\n\n        // refuse if same row\n        if (source_coords[1] === target_coords[1]) {\n            return false;\n        }\n\n        // refuse if spanning more than 1 rows\n        if (Math.abs(source_coords[1] - target_coords[1]) > 1) {\n            return false;\n        }\n\n        // target row index out of bounds check\n        if (target_coords[1] >= this.nodes.length) {\n            return false;\n        }\n\n        // target col index out of bounds check\n        if (target_coords[0] >= this.nodes[target_coords[1]].columns.length) {\n            return false;\n        }\n\n        // check if target is parent or child\n        var is_target_parent = target_coords[1] < source_coords[1];\n        var source = this.nodes[source_coords[1]].columns[source_coords[0]];\n        var target = this.nodes[target_coords[1]].columns[target_coords[0]];\n        var result;\n\n        // if target is parent, then check if target has connected lines to source\n        if (is_target_parent) {\n\n            result = false;\n\n            // check that last exit was not bottom\n            if (this.source_exit_side === 'bottom') {\n                return false;\n            }\n\n            // check if target has an connected line from it source\n            _.forEach(target.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, source_coords)) {\n                    result = true;\n                    return false;\n                }\n            });\n        }\n\n        // if target is child, then\n        else {\n\n            result = true;\n\n            // check that last exit was not top\n            if (this.source_exit_side === 'top') {\n                return false;\n            }\n\n            // check if source does not have an connected line to it\n            _.forEach(source.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, target_coords)) {\n                    result = false;\n                    return false;\n                }\n            });\n        }\n\n        return result;\n    }\n\n    //-----------------------------\n    // node classes\n    //-----------------------------\n\n    /**\n     * setLineClass\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param key\n     * @param value\n     */\n    setLineClass(source_coords, target_coords, key, value) {\n\n        // loop child row columns\n        _.forEach(this.nodes[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            // if child node is potential then update class property\n            if (_.isEqual(line.to, target_coords)) {\n                line[key] = value;\n            }\n        });\n    }\n\n    /**\n     * setNodeClass\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setNodeClass(row_index, col_index, key, value) {\n        if (_.has(this.nodes[row_index].columns[col_index], key)) {\n            this.nodes[row_index].columns[col_index][key] = value;\n        }\n    }\n\n    /**\n     * setPotentialNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialNodeClasses(row_index, col_index, key, value) {\n\n        this.setPotentialChildNodeClasses(row_index, col_index, key, value);\n        this.setPotentialParentNodeClasses(row_index, col_index, key, value);\n    }\n\n    /**\n     * setPotentialChildNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialChildNodeClasses(row_index, col_index, key, value) {\n\n        // if child row is not out of bounds\n        if ((row_index + 1) < (this.nodes.length)) {\n\n            // loop child row columns\n            _.forEach(this.nodes[row_index + 1].columns, (child_col, child_col_index) => {\n\n                // if child node is potential then update class property\n                if (this.isNodePotential([col_index, row_index], [child_col_index, row_index + 1])) {\n                    child_col[key] = value;\n                }\n            });\n        }\n    }\n\n    /**\n     * setPotentialParentNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialParentNodeClasses(row_index, col_index, key, value) {\n\n        if (row_index > 0) {\n\n            // loop parent node columns\n            _.forEach(this.nodes[row_index - 1].columns, (parent_col, parent_col_index) => {\n\n                // if parent node is potential then update class property\n                if (this.isNodePotential([col_index, row_index], [parent_col_index, row_index - 1])) {\n                    parent_col[key] = value;\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // viewport\n    //-----------------------------\n\n    /**\n     * setViewport\n     *\n     * @param cols\n     * @param rows\n     */\n    setViewport(cols, rows) {\n\n        var total_item_width = this.config.node_width + this.config.col_spacing;\n        var total_item_height = this.config.node_height + this.config.row_spacing;\n\n        this.viewport_width = total_item_width * cols;\n        this.viewport_height = total_item_height * rows;\n\n        this.viewport_style = {\n            'background-color': \"#ccc\",\n            'min-width': this.viewport_width + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.wrapper_style = {\n            'max-width': (this.viewport_width + this.config.max_viewport_width_increase) + \"px\",\n            'min-width': this.viewport_width + \"px\",\n            'max-height': (this.viewport_height + (this.config.max_viewport_height_increase * rows)) + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.viewport_viewbox = \" 0 0 \" + this.viewport_width + \" \" + this.viewport_height;\n    }\n\n    /**\n     * checkViewport\n     *\n     * @param col_index\n     * @param row_index\n     */\n    checkViewport(col_index, row_index) {\n\n        var should_update_viewport = false;\n\n        // row bounds check\n        if (row_index >= this.grid_row_count) {\n\n            // increase rowspan\n            this.grid_row_count++;\n            should_update_viewport = true;\n        }\n\n        // col bounds check\n        if (col_index >= this.grid_col_count) {\n\n            // increase colspan\n            this.grid_col_count++;\n            should_update_viewport = true;\n\n            // add bg grid col\n            this.addBgGridCol(this.grid_col_count - 1);\n        }\n\n        // set viewport\n        if (should_update_viewport) {\n            this.setViewport(this.grid_col_count, this.grid_row_count);\n        }\n    }\n\n    //-----------------------------\n    // coords\n    //-----------------------------\n\n    /**\n     * calculateColX\n     *\n     * @param index\n     */\n    calculateColX(index) {\n        if (index === 0) {\n            return 0;\n        }\n        var first_col_width = this.config.node_width + (this.config.col_spacing / 2);\n        var col_width = this.config.node_width + (this.config.col_spacing);\n        return first_col_width + ((index - 1) * col_width);\n    }\n\n    /**\n     * calculateColWidth\n     *\n     * @param index\n     */\n    calculateColWidth(index) {\n        var total_item_width = index === 0 ? this.config.node_width + (this.config.col_spacing / 2) : this.config.node_width + this.config.col_spacing;\n        return total_item_width;\n    }\n\n    /**\n     * calculateRowY\n     *\n     * @param index\n     */\n    calculateRowY(index) {\n        var row_height = this.config.node_height + this.config.row_spacing;\n        return index * row_height;\n    }\n\n    /**\n     * calculateRowHeight\n     *\n     * @param index\n     */\n    calculateRowHeight() {\n        return this.config.node_height + this.config.row_spacing;\n    }\n\n    //-----------------------------\n    // drawing\n    //-----------------------------\n\n    /**\n     * addLine\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    addLine(source_coords, target_coords, connected) {\n\n        // check bounds\n        if (target_coords[1] >= this.nodes.length) {\n            return false;\n        }\n\n        // get coords\n        var source_lock_coords = Utils.getNodeCoords(source_coords[1], source_coords[0], NODE_BOTTOM, this.config);\n        var target_lock_coords = Utils.getNodeCoords(target_coords[1], target_coords[0], NODE_TOP, this.config);\n\n        // add line properties\n        this.nodes[source_coords[1]].columns[source_coords[0]].lines.push({\n            connected: !_.isUndefined(connected) ? connected : false,\n            from: source_coords,\n            to: target_coords,\n            x1: source_lock_coords[0],\n            y1: source_lock_coords[1],\n            x2: target_lock_coords[0],\n            y2: target_lock_coords[1]\n        });\n\n        if (connected) {\n            // update data\n            // this.state[source_coords[1]].columns[source_coords[0]].join.push(target_coords[0]);\n        }\n    }\n\n    /**\n     * updateLineTarget\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    updateLineTarget(source_coords, target_coords) {\n\n        // get target lock coords\n        var target_lock_coords = Utils.getNodeCoords(target_coords[1], target_coords[0], NODE_TOP, this.config);\n\n        // find line\n        _.forEach(this.nodes[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.to = target_coords;\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeLine\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param set_as_busy\n     */\n    removeLine(source_coords, target_coords, set_as_busy) {\n\n        if (set_as_busy) {\n            this.is_connection_change_busy = true;\n        }\n\n        // get target lock coords\n        var target_lock_coords = Utils.getNodeCoords(source_coords[1], source_coords[0], NODE_BOTTOM, this.config);\n\n        // find line\n        _.forEach(this.nodes[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                var node = this.nodes[target_coords[1]].columns[target_coords[0]];\n                var node_has_connected_parents = this.doesNodeHaveConnectedParents(target_coords[0], target_coords[1], source_coords);\n\n                // if node has no lines & has no parent connections\n                if (node.lines.length === 0 && !node_has_connected_parents) {\n                    // set as not connected\n                    this.setAsNotConnectedNode(target_coords);\n                }\n\n                // if node has no parent connections\n                var node_has_active_parents = this.doesNodeHaveActiveParents(target_coords[0], target_coords[1], source_coords);\n\n                if (!node_has_active_parents) {\n\n                    // deactivate node\n                    this.deactivateNode(target_coords[0], target_coords[1]);\n                }\n\n                // set line properties\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.previous_to = line.to; // TODO: this feels a bit hacky\n                line.to = [source_coords[0], source_coords[1]];\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeUnconnectedLines\n     *\n     * @param selection\n     */\n    removeUnconnectedLines(selection) {\n        _.forEach(this.nodes[selection[0][1]].columns[selection[0][0]].lines, (line) => {\n            if (!line.connected) {\n                this.removeLine(this.selection[0], this.selection[1]);\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedLines\n     *\n     * @param selection\n     */\n    setAsConnectedLines(selection) {\n\n        _.forEach(this.nodes[selection[0][1]].columns[selection[0][0]].lines, (line, line_index) => {\n            if (!line.connected) {\n\n                // setAsConnected line\n                line.connected = true;\n\n                // setAsConnected nodes\n                this.setAsConnectedNode(line.from);\n                this.setAsConnectedNode(line.to);\n\n                // external callback\n                if (!_.isUndefined(this.onNodeConnectionChangeCallback)) {\n\n                    // so that onNodeDeselection can decide whether to call as well\n                    this.was_connection_change_called = true;\n\n                    let _params = {\n                        source_row_index: line.from[1],\n                        source_col_index: line.from[0],\n                        target_row_index: line.to[1],\n                        target_col_index: line.to[0],\n                        is_connected: true\n                    };\n                    this.onNodeConnectionChangeCallback(_params);\n                }\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedNode\n     *\n     * @param coords\n     */\n    setAsConnectedNode(coords) {\n        this.nodes[coords[1]].columns[coords[0]].connected = true;\n    }\n\n    /**\n     * setAsNotConnectedNode\n     *\n     * @param coords\n     */\n    setAsNotConnectedNode(coords) {\n        this.nodes[coords[1]].columns[coords[0]].connected = false;\n    }\n\n    /**\n     * addNode\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     * @param lines\n     * @param data\n     * @returns {boolean}\n     */\n    addNode(row_index, col_index, label, lines, data) {\n\n        // create row if it doesn't exist\n        if (row_index === this.nodes.length) {\n            this.nodes.push({columns: []});\n        }\n\n        // if node already exists (control) then remove and re-add after node\n        var removed_node;\n\n        if (!_.isUndefined(this.nodes[row_index].columns[col_index])) {\n            removed_node = this.nodes[row_index].columns.splice(col_index, 1);\n        }\n\n        // get top left coords\n        var top_left_coords = Utils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n\n        // lines\n        var node_lines = [];\n        var line_source_lock_coords = Utils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n        _.forEach(lines, (line_target_col_index) => {\n\n            var line_target_coords = [line_target_col_index, row_index + 1];\n            var line_target_lock_coords = Utils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n            node_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set nodes as connected\n            this.nodes_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set node properties\n        var node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: label,\n            connected: node_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: node_lines,\n            selected: _.has(data, \"selected\") ? data.selected : false,\n            highlight: _.has(data, \"highlight\") ? data.highlight : false\n        };\n\n        // if this node is selected\n        if (node.selected) {\n\n            // ... and there is another node already selected\n            // ... then remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = node.row_index;\n            this.highlight_selected_node.col_index = node.col_index;\n        }\n\n        // add node\n        this.nodes[row_index].columns.push(node);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n        // replace removed node\n        if (!_.isUndefined(removed_node)) {\n            this.addControl(removed_node[0].row_index);\n        }\n\n        this.new_node = { row_index, col_index };\n\n        // highlight node\n        // ... if configured to do so\n        // ... and not initialising\n\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_ADD) && !this.is_initialising) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[row_index].columns[col_index].selected = true;\n        }\n\n        // external callback\n        // ... if not initialising\n        if (!_.isUndefined(this.onNodeAddedCallback) && !this.is_initialising) {\n            this.onNodeAddedCallback({ row_index, col_index });\n        }\n    }\n\n    /**\n     * updateNode\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     * @param lines\n     */\n    updateNode(row_index, col_index, label, lines = []) {\n\n        // update label\n        if (!_.isUndefined(label) && this.nodes[row_index].columns[col_index].label !== label) {\n            this.nodes[row_index].columns[col_index].label = label;\n        }\n\n        // update lines\n        if (!_.isUndefined(lines)) {\n\n            var line_source_lock_coords     = Utils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n            _.forEach(lines, (line_target_col_index) => {\n\n                var line_target_coords = [line_target_col_index, row_index + 1];\n                var line_target_lock_coords     = Utils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n                // if already has this connection\n                if (_.includes(_.map(this.nodes[row_index].columns[col_index].lines, (line) => line.to[0]), line_target_col_index)) {\n                    return;\n                }\n\n                this.nodes[row_index].columns[col_index].lines.push({\n                    connected: true,\n                    from: [col_index, row_index],\n                    to: line_target_coords,\n                    x1: line_source_lock_coords[0],\n                    y1: line_source_lock_coords[1],\n                    x2: line_target_lock_coords[0],\n                    y2: line_target_lock_coords[1]\n                });\n\n                this.setNodeClass(row_index, col_index, 'connected', true);\n\n                // set nodes as connected\n                this.nodes_waiting_for_connection.push(line_target_coords);\n            });\n        }\n    }\n\n    /**\n     * removeNode\n     *\n     * @param col_index\n     * @param row_index\n     */\n    removeNode(col_index, row_index) {\n\n        // remove lines\n        let _set_as_busy = false;\n        _.forEach(this.nodes[row_index].columns[col_index].lines, (line) => {\n            this.removeLine(line.from, line.to, _set_as_busy);\n        });\n\n        // remove node\n        this.nodes[row_index].columns.splice(col_index, 1);\n\n        // update data\n        // this.state[row_index].columns.splice(col_index, 1);\n\n        // update siblings\n        for (var i = col_index; i < (this.nodes[row_index].columns.length); i++) {\n            this.updateNodeAfterSiblingAddedOrRemoved(i, row_index);\n\n            // if not last column (control)\n            if (i < this.nodes[row_index].columns.length - 1) {\n                // TODO: why not update nodes???\n                // this.state[row_index].columns[i].data.ui_column_index = i;\n                // this.state[row_index].columns[i].data.ui_row_index = row_index;\n            }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            var parent_row_index = row_index - 1;\n            let remove_lines = [];\n\n            _.forEach(this.nodes[parent_row_index].columns, (column, parent_col_index) => {\n                _.forEach(column.lines, (line, line_index) => {\n\n                    // if parent connects to this node\n                    if (_.isEqual(line.to, [col_index, row_index])) {\n\n                        // column.lines.splice(line_index, 1);\n\n                        // mark lines for removal\n                        remove_lines.push({\n                            row_index: parent_row_index,\n                            col_index: parent_col_index,\n                            line_index: line_index\n                        });\n\n                        // update data\n                        //this.state[parent_row_index].columns[parent_col_index].join.splice(line_index, 1);\n\n                        // if parent no longer has any lines\n                        if (column.lines.length === 0) {\n                            this.setAsNotConnectedNode([parent_col_index, parent_row_index]);\n                        }\n                    }\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] > col_index) {\n\n                        // update lines target\n                        var new_line_to = [line.to[0] - 1, line.to[1]];\n\n                        // get target lock coords\n                        var target_lock_coords = Utils.getNodeCoords(new_line_to[1], new_line_to[0], NODE_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n\n            // remove lines\n            _.map(remove_lines, (data) => {\n                this.nodes[data.row_index].columns[data.col_index].lines.splice(data.line_index, 1);\n            });\n        }\n\n        // update children\n        // TODO: can we use node???\n        if (row_index !== this.nodes.length - 1) {\n            var children_row_index = row_index + 1;\n            _.forEach(this.nodes[children_row_index].columns, (column, children_col_index) => {\n\n                // if  node has no parent connections\n                if (!this.doesNodeHaveConnectedParents(children_col_index, children_row_index)) {\n                    this.setAsNotConnectedNode([children_col_index, children_row_index]);\n                }\n            });\n        }\n    }\n\n    /**\n     * insertNode\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     * @param joins\n     * @returns {boolean}\n     */\n    insertNode(row_index, col_index, label, joins) {\n\n        // get top left coords\n        var top_left_coords = Utils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n\n        // lines\n        var node_lines = [];\n        var line_source_lock_coords = Utils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n        _.forEach(joins, (line_target_col_index) => {\n\n            var line_target_coords = [line_target_col_index, row_index + 1];\n            var line_target_lock_coords = Utils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n            node_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set nodes as connected\n            this.nodes_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set node properties\n        var node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: label,\n            connected: node_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: node_lines\n        };\n\n        // TODO: add highlight and selected\n\n        // insert node\n        this.nodes[row_index].columns.splice(col_index, 0, node);\n\n        // update data\n        //this.state[row_index].columns.splice(col_index, 0, data);\n\n        // update siblings\n        for (var i = col_index + 1; i < (this.nodes[row_index].columns.length); i++) {\n\n            this.updateNodeAfterSiblingAddedOrRemoved(i, row_index);\n\n            // if not last column (control)\n            // if (i < this.nodes[row_index].columns.length - 1) {\n            //     this.state[row_index].columns[i].data.ui_column_index = i;\n            //     this.state[row_index].columns[i].data.ui_row_index = row_index;\n            // }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            var parent_row_index = row_index - 1;\n            _.forEach(this.nodes[parent_row_index].columns, (column) => {\n                _.forEach(column.lines, (line) => {\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] >= col_index) {\n\n                        // update lines target\n                        var new_line_to = [line.to[0] + 1, line.to[1]];\n\n                        // get target lock coords\n                        var target_lock_coords = Utils.getNodeCoords(new_line_to[1], new_line_to[0], NODE_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * updateNodeAfterSiblingAddedOrRemoved\n     *\n     * @param {Integer}    col_index\n     * @param {Integer}    row_index\n     */\n    updateNodeAfterSiblingAddedOrRemoved(col_index, row_index) {\n\n        var top_left_coords = Utils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        var center_coords = Utils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // update node\n\n        this.nodes[row_index].columns[col_index].col_index = col_index;\n        this.nodes[row_index].columns[col_index].coords = top_left_coords;\n        this.nodes[row_index].columns[col_index].x = top_left_coords[0];\n        this.nodes[row_index].columns[col_index].y = top_left_coords[1];\n\n        // update labels\n        // last node has different label position\n        if (col_index === (this.nodes[row_index].columns.length - 1)) {\n            this.nodes[row_index].columns[col_index].label_x = center_coords[0];\n            this.nodes[row_index].columns[col_index].label_y = center_coords[1];\n        } else {\n            this.nodes[row_index].columns[col_index].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.nodes[row_index].columns[col_index].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.nodes[row_index].columns[col_index].lines, (line) => {\n\n            // get target lock coords\n            var source_lock_coords = Utils.getNodeCoords(row_index, col_index, NODE_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * updateNodeAfterChildAddedOrRemoved\n     *\n     * @param {Integer}    col_index\n     * @param {Integer}    row_index\n     */\n    updateNodeAfterChildAddedOrRemoved(col_index, row_index) {\n\n        var top_left_coords = Utils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        var center_coords = Utils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // update node\n\n        this.nodes[row_index].columns[col_index].col_index = col_index;\n        this.nodes[row_index].columns[col_index].coords = top_left_coords;\n        this.nodes[row_index].columns[col_index].x = top_left_coords[0];\n        this.nodes[row_index].columns[col_index].y = top_left_coords[1];\n\n        // update labels\n        // last node has different label position\n        if (col_index === (this.nodes[row_index].columns.length - 1)) {\n            this.nodes[row_index].columns[col_index].label_x = center_coords[0];\n            this.nodes[row_index].columns[col_index].label_y = center_coords[1];\n        } else {\n            this.nodes[row_index].columns[col_index].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.nodes[row_index].columns[col_index].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.nodes[row_index].columns[col_index].lines, (line) => {\n\n            // get target lock coords\n            var source_lock_coords = Utils.getNodeCoords(row_index, col_index, NODE_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * addControl\n     *\n     * @param {Integer}    row_index\n     */\n    addControl(row_index) {\n\n        // create row if it doesn't exist\n        if (row_index === this.nodes.length) {\n            this.nodes.push({columns: []});\n        }\n\n        // validate row index\n        if (row_index >= this.nodes.length) {\n            throw new Error(\"Invalid row index\");\n        }\n\n        var col_index = this.nodes[row_index].columns.length;\n\n        // get top left coords\n        var top_left_coords = Utils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        var center_coords = Utils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // set node properties\n        var node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: center_coords[0],\n            label_y: center_coords[1],\n            label: \"+\",\n            connected: false,\n            control: true,\n            row_index: row_index,\n            col_index: col_index,\n            lines: []\n        };\n\n        // add node\n        this.nodes[row_index].columns.push(node);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n    }\n\n    /**\n     * addBgGridCol\n     *\n     * @param {Integer}    index\n     */\n    addBgGridCol(index) {\n\n        this.bg_col_grid.push({\n            index: index,\n            x: this.calculateColX(index),\n            width: this.calculateColWidth(index)\n        });\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // update\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * update\n     *\n     * @param data\n     * @param column_property_name\n     */\n    update(data, column_property_name) {\n\n        // add controls\n        _.forEach(data, (row, row_index) => {\n\n            // ... if row index exceeds or equals current UI rows\n            if (row_index >= this.nodes.length) {\n                this.addControl(row_index);\n            }\n        });\n\n        // add nodes\n        _.forEach(data, (row, row_index) => {\n            _.forEach(row[column_property_name], (col, col_index) => {\n\n                // update node\n                this.updateNode(row_index, col_index, col.label);\n\n                // ... if column index exceeds or equals current UI cols (excluding control)\n                if (col_index >= this.nodes[row_index].columns.length - 1) {\n                    var label = _.has(col, 'label') ? col.label : \"\";\n                    var lines = _.has(col, 'join') ? col.join : [];\n                    this.addNode(row_index, col_index, label, lines);\n                }\n            });\n        });\n\n        // set viewport\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        // check active\n        this.checkActive();\n    }\n}\n\nAngularSvgNodesController.$inject = [ '$scope' ];"],"sourceRoot":"src/app/*.js"}