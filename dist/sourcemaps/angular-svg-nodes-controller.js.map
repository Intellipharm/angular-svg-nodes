{"version":3,"sources":["angular-svg-nodes-controller.js"],"names":[],"mappings":"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","file":"angular-svg-nodes-controller.js","sourcesContent":["// local: constants\nimport {\n    HIGHLIGHT_NODE_ON_SELECT,\n    HIGHLIGHT_NODE_ON_DESELECT,\n    HIGHLIGHT_NODE_ON_ADD,\n    DEFAULT_HIGHLIGHT_NODE_ON,\n    DEFAULT_INITIAL_GRID_COLS,\n    DEFAULT_INITIAL_GRID_ROWS,\n    DEFAULT_NODE_WIDTH,\n    DEFAULT_NODE_HEIGHT,\n    DEFAULT_COL_SPACING,\n    DEFAULT_ROW_SPACING,\n    DEFAULT_LABEL_SPACING,\n    DEFAULT_DISABLE_CONTROL_NODES,\n    DEFAULT_MAX_VIEWPORT_WIDTH_INCREASE,\n    DEFAULT_MAX_VIEWPORT_HEIGHT_INCREASE\n} from \"./angular-svg-nodes-settings\";\nimport {\n    NODE_TOP_LEFT,\n    NODE_TOP,\n    NODE_CENTER,\n    NODE_BOTTOM,\n    DEFAULT_NEW_NODE_LABEL\n} from \"./node/node-settings\";\n\n// local: services\nimport * as Utils from './angular-svg-nodes-utils';\nimport * as NodeUtils from './node/node-utils';\nimport * as ApiValidator from './api/api-validator';\n\nexport default class AngularSvgNodesController {\n\n    constructor($s) {\n\n        this.$s = $s;\n\n        //-----------------------------\n        // directives vars\n        //-----------------------------\n        //\n        // this.initial_state\n        // this.api\n        //\n        //-----------------------------\n\n        if (_.isUndefined(this.api)) {\n            this.api = {};\n        }\n\n        //-----------------------------\n        // state\n        //-----------------------------\n\n        this.state = [];\n\n        //-----------------------------\n        // config\n        //-----------------------------\n\n        // TODO: validate highlight node on array (remove invalid options)\n\n        this.config = {\n            new_node_label:                 !_.isUndefined(this.config_new_node_label) ? this.config_new_node_label : DEFAULT_NEW_NODE_LABEL,\n            initial_grid_cols:              !_.isUndefined(this.config_initial_grid_cols) ? this.config_initial_grid_cols : DEFAULT_INITIAL_GRID_COLS,\n            initial_grid_rows:              !_.isUndefined(this.config_initial_grid_rows) ? this.config_initial_grid_rows : DEFAULT_INITIAL_GRID_ROWS,\n            highlight_node_on:              !_.isUndefined(this.config_highlight_node_on) ? this.config_highlight_node_on : DEFAULT_HIGHLIGHT_NODE_ON,\n            node_width:                     !_.isUndefined(this.config_node_width) ? this.config_node_width : DEFAULT_NODE_WIDTH,\n            node_height:                    !_.isUndefined(this.config_node_height) ? this.config_node_height : DEFAULT_NODE_HEIGHT,\n            col_spacing:                    !_.isUndefined(this.config_col_spacing) ? this.config_col_spacing : DEFAULT_COL_SPACING,\n            row_spacing:                    !_.isUndefined(this.config_row_spacing) ? this.config_row_spacing : DEFAULT_ROW_SPACING,\n            label_spacing:                  !_.isUndefined(this.config_label_spacing) ? this.config_label_spacing : DEFAULT_LABEL_SPACING,\n            disable_control_nodes:          !_.isUndefined(this.config_disable_control_nodes) ? this.config_disable_control_nodes : DEFAULT_DISABLE_CONTROL_NODES,\n            max_viewport_width_increase:    !_.isUndefined(this.config_max_viewport_width_increase) ? this.config_max_viewport_width_increase : DEFAULT_MAX_VIEWPORT_WIDTH_INCREASE,\n            max_viewport_height_increase:   !_.isUndefined(this.config_max_viewport_height_increase) ? this.config_max_viewport_height_increase : DEFAULT_MAX_VIEWPORT_HEIGHT_INCREASE\n        };\n\n        //-----------------------------\n        // control\n        //-----------------------------\n\n        this.is_initialising = false;\n\n        // allows onNodeDeselection to decide whether or not to fire external callback straight after onConnectionChange callback was fired\n        this.was_connection_change_called = false;\n        this.is_connection_change_busy = false;\n\n        // an array of node coords that will be set as connected on teh line\n        this.nodes_waiting_for_connection = [];\n\n        // parent coordinates (for reference)\n        this.parent_coords = [];\n\n        // view coordinates (for reference)\n        this.coords = [];\n\n        // view element data\n        this.nodes = [];\n\n        // array for bg grid\n        this.bg_col_grid = [];\n        this.bg_col_grid_hover_index = null;\n\n        // grid dimmensions\n        this.grid_col_count = this.config.initial_grid_cols;\n        this.grid_row_count = this.config.initial_grid_rows;\n        this.label_width = this.config.node_width - (this.config.label_spacing * 2);\n        this.label_height = this.config.node_height - (this.config.label_spacing * 2);\n\n        // viewport style & bounds\n        this.wrapper_style = \"\";\n        this.viewport_style = \"\";\n        this.viewport_width = 0;\n        this.viewport_height = 0;\n        this.viewport_viewbox = \"\";\n\n        // node selections\n        this.selection = [];\n        this.source_exit_side = null;\n\n        // active node\n        this.selected_node = [];\n\n        // highlighted selected node\n        this.highlight_selected_node = {};\n\n        this.new_node = {};\n\n        ////////////////////////////////////////////////\n        //\n        // watchers\n        //\n        ////////////////////////////////////////////////\n\n        this.$s.$watch('AngularSvgNodes.selection', (newValue, oldValue) => {\n\n            if (_.isUndefined(newValue)) {\n                return;\n            }\n\n            // two selected & target is child of source\n            if (newValue.length === 2 && newValue[1][1] > newValue[0][1]) {\n\n                // new target selection\n                if (newValue.length > oldValue.length) {\n\n                    // add line\n                    this.addLine(this.selection[0], this.selection[1]);\n                }\n\n                // updated target selection\n                else {\n\n                    // update line\n                    this.updateLineTarget(this.selection[0], this.selection[1]);\n                }\n            }\n        }, true);\n\n        this.$s.$watch('AngularSvgNodes.initial_state', (newValue, oldValue) => {\n\n            this.init();\n        });\n\n        ////////////////////////////////////////////////\n        //\n        // api\n        //\n        ////////////////////////////////////////////////\n\n        /**\n         * addRow\n         *\n         * @param label\n         */\n        this.api.addRow = (label = \"\") => {\n\n            let _row_index = this.nodes.length;\n            let _col_index = 0;\n\n            this.addNode(_row_index, _col_index, label, []);\n            this.addControlNode(_row_index);\n        };\n\n        /**\n         * removeNode\n         *\n         * @param row_index\n         * @param col_index\n         */\n        this.api.removeNode = (row_index, col_index) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.removeNode(row_index, col_index);\n        };\n\n        /**\n         * insertNode\n         *\n         * @param row_index\n         * @param col_index\n         * @param label\n         * @param connections\n         */\n        this.api.insertNode = (row_index, col_index, label, connections) => {\n\n            if (!ApiValidator.areApiCoordsValidForInsert(this.nodes, row_index, col_index)) {\n                return;\n            }\n            if (!ApiValidator.areApiConnectionsValid(this.nodes, row_index - 1, connections)) {\n                return;\n            }\n\n            this.insertNode(row_index, col_index, label, connections);\n        };\n\n        /**\n         * updateNodeConnections\n         *\n         * @param row_index\n         * @param col_index\n         * @param connections\n         */\n        this.api.updateNodeConnections = (row_index, col_index, connections) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n            if (!ApiValidator.areApiConnectionsValid(this.nodes, row_index, connections)) {\n                return;\n            }\n\n            let _label = this.nodes[ row_index ].columns[ col_index ].label;\n            let _lines = _.map(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n                return _.has(line, 'to') ? line.to[0] : line;\n            });\n            let _connections = _.uniq([ ..._lines, ...connections ]);\n\n            this.updateNode(row_index, col_index, _label, _connections);\n        };\n\n        /**\n         * setNodeLabel\n         *\n         * @param row_index\n         * @param col_index\n         * @param label\n         */\n        this.api.setNodeLabel = (row_index, col_index, label) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.updateNode(row_index, col_index, label);\n        };\n\n        /**\n         * setNodeHighlight\n         *\n         * @param row_index\n         * @param col_index\n         * @param value\n         */\n        this.api.setNodeHighlight = (row_index, col_index, value) => {\n\n            if (!ApiValidator.areApiCoordsValid(this.nodes, row_index, col_index)) {\n                return;\n            }\n\n            this.nodes[ row_index ].columns[ col_index ].highlight = value;\n        };\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // init\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * init\n     */\n    init() {\n\n        this.is_initialising = true;\n\n        // resets\n        this.nodes = [];\n\n        let _column_property_name = 'columns';\n        let _data = !_.isUndefined(this.initial_state) ?  this.initial_state : [];\n\n        // add nodes\n        _.forEach(_data, (row, row_index) => {\n\n            _.forEach(row[ _column_property_name ], (col, col_index) => {\n\n                this.addNode(row_index, col_index, col.label, col.join, col);\n            });\n\n            this.addControlNode(row_index);\n        });\n\n        // add bg_col_grid array\n        _.map(new Array(this.grid_col_count), (col, index) => {\n            this.addBgGridCol(index);\n        });\n\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        this.checkActive();\n\n        this.update(_data, _column_property_name);\n\n        this.is_initialising = false;\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // handlers\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // general\n    //-----------------------------\n\n    /**\n     * onNodeSelect\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onNodeSelect(row_index, col_index) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            if (!this.config.disable_control_nodes) {\n                this.onControlNodeSelect(row_index, col_index);\n            }\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeSelect(row_index, col_index);\n\n        // highlight node\n        // ... if configured to do so\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_SELECT)) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[ row_index ].columns[ col_index ].selected = true;\n        }\n\n        // external callback\n        if (!_.isUndefined(this.onNodeSelectionCallback)) {\n            this.onNodeSelectionCallback({ row_index, col_index });\n        }\n    }\n\n    /**\n     * onNodeDeselect\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onNodeDeselect(row_index, col_index) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            return false;\n        }\n\n        // if node\n        this.onNodeNodeDeselect(row_index, col_index);\n\n        let _is_new_node = _.isEqual(this.new_node, { row_index, col_index });\n\n        // highlight node\n        // ... if configured to do so\n        // ... and node is not new node (just added)\n        // ... and connection change callback was not just called\n        // ... and connection change is not busy (happens on line remove)\n\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_DESELECT) && !_is_new_node && !this.was_connection_change_called && !this.is_connection_change_busy) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[ row_index ].columns[ col_index ].selected = true;\n        }\n\n        // external callback\n        // ... if connection change callback was not just called\n        // ... and connection change is not busy (happens on line remove)\n\n        if (!_.isUndefined(this.onNodeDeselectionCallback) && !_is_new_node && !this.was_connection_change_called && !this.is_connection_change_busy) {\n            this.onNodeDeselectionCallback({ row_index, col_index });\n        }\n\n        this.new_node = {}; // reset\n        this.was_connection_change_called = false; // reset\n    }\n\n    /**\n     * onNodeMouseOver\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onNodeMouseOver(row_index, col_index) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            this.onControlNodeMouseOver(row_index, col_index);\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeMouseOver(row_index, col_index);\n    }\n\n    /**\n     * onNodeMouseOut\n     *\n     * @param row_index\n     * @param col_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeMouseOut(row_index, col_index, exit_side) {\n\n        // if control\n        if (this.nodes[ row_index ].columns[ col_index ].control) {\n            this.onControlNodeMouseOut(row_index, col_index);\n            return true;\n        }\n\n        // if node\n        this.onNodeNodeMouseOut(row_index, col_index, exit_side);\n    }\n\n    //-------------------------------------------------\n    // control node handlers\n    //-------------------------------------------------\n\n    /**\n     * onControlNodeSelect\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onControlNodeSelect(row_index, col_index) {\n\n        let _label = _.isFunction(this.config.new_node_label) ? this.config.new_node_label(row_index, col_index) : this.config.new_node_label;\n\n        this.addNode(row_index, col_index, _label, []);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOver\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onControlNodeMouseOver(row_index, col_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(row_index, col_index, 'control_hover', true);\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onControlNodeMouseOut\n     *\n     * @param row_index\n     * @param col_index\n     * @returns {boolean}\n     */\n    onControlNodeMouseOut(row_index, col_index) {\n\n        // disallow if selection\n        if (this.selection.length > 0) {\n            return false;\n        }\n\n        // styles\n        this.setNodeClass(row_index, col_index, 'control_hover', false);\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // node node handlers\n    //-------------------------------------------------\n\n    /**\n     * onNodeNodeSelect\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onNodeNodeSelect(row_index, col_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        this.setNodeClass(row_index, col_index, 'source_hover', false);\n        this.setNodeClass(row_index, col_index, 'source', true);\n        this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', false);\n        this.setPotentialNodeClasses(row_index, col_index, 'potential_target', true);\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // set selection\n        this.selection = [[ col_index, row_index ]];\n        this.selected_node = [ col_index, row_index ];\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onNodeNodeDeselect\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onNodeNodeDeselect(row_index, col_index) {\n\n        // reset last exit side\n        this.source_exit_side = null;\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if one selection\n        if (this.selection.length === 1) {\n\n            // if deselecting on current source\n            if (_.isEqual(this.selection[0], [ col_index, row_index ])) {\n\n                this.setNodeClass(row_index, col_index, 'source', false);\n                this.setNodeClass(row_index, col_index, 'source_hover', true);\n                this.setPotentialNodeClasses(row_index, col_index, 'potential_target', false);\n                this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', true);\n            }\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if deselecting on current target (& is potential ?)\n            if (_.isEqual(this.selection[1], [ col_index, row_index ])) {\n\n                this.setNodeClass(row_index, col_index, 'target', false);\n\n                // if  node has no parent connections\n                if (!this.doesNodeHaveConnectedParents(row_index, col_index)) {\n                    this.setPotentialNodeClasses(row_index, col_index, 'potential_target', false);\n                }\n\n                // check active\n                this.checkActive();\n            }\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // if deselecting on current target & is potential\n            if (_.isEqual(this.selection[1], [ col_index, row_index ]) && this.isNodePotential(this.selection[0], [ col_index, row_index ])) {\n\n                let is_target_parent = this.selection[0][1] > row_index;\n\n                // if target is parent then remove line\n                if (is_target_parent) {\n                    this.removeLine(this.selection[1], this.selection[0]);\n                }\n\n                // if target is child then setAsConnected line\n                else {\n                    this.setAsConnectedLines(this.selection);\n\n                    // check active\n                    this.checkActive();\n                }\n            }\n        }\n    }\n\n    /**\n     * onNodeNodeMouseOver\n     *\n     * @param row_index\n     * @param col_index\n     */\n    onNodeNodeMouseOver(row_index, col_index) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selection\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(row_index, col_index, 'source_hover', true);\n            this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', true);\n        }\n\n        // if two selections\n        if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [ col_index, row_index ])) {\n\n                this.setNodeClass(row_index, col_index, 'potential_target', false);\n                this.setNodeClass(row_index, col_index, 'target', true);\n                this.setLineClass(this.selection[0], [ col_index, row_index ], 'target', true);\n            }\n        }\n\n        // if col changed\n        if (this.bg_col_grid_hover_index !== col_index) {\n\n            //this.bg_col_grid_hover_index = col_index;\n\n            //-------------------------\n            // selection updates\n            //-------------------------\n\n            // if 2 selections and new col index is potential\n            //if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [col_index, this.selection[1][1]])) {\n            //    this.selection[1][0] = col_index;\n            //}\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onNodeNodeMouseOut\n     *\n     * @param row_index\n     * @param col_index\n     * @param exit_side\n     * @returns {boolean}\n     */\n    onNodeNodeMouseOut(row_index, col_index, exit_side) {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if no selections\n        if (this.selection.length === 0) {\n\n            this.setNodeClass(row_index, col_index, 'source_hover', false);\n            this.setPotentialNodeClasses(row_index, col_index, 'potential_target_hover', false);\n        }\n\n        // if two selections\n        else if (this.selection.length === 2) {\n\n            // if potential\n            if (this.isNodePotential(this.selection[0], [ col_index, row_index ])) {\n\n                this.setNodeClass(row_index, col_index, 'target', false);\n                this.setNodeClass(row_index, col_index, 'potential_target', true);\n                this.setLineClass(this.selection[0], [ col_index, row_index ], 'target', false);\n            }\n        }\n\n        // if this is source selection & source_exit_side not yet set\n        if (_.isEqual(this.selection[0], [ col_index, row_index ]) && _.isNull(this.source_exit_side)) {\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                // remove 'potential child' class from potential children\n                this.setPotentialChildNodeClasses(row_index, col_index, 'potential_target', false);\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                // remove 'potential child' class from potential parent\n                this.setPotentialParentNodeClasses(row_index, col_index, 'potential_target', false);\n            }\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if one selection one selected\n        if (this.selection.length === 1) {\n\n            // if this is source selection\n            if (_.isEqual(this.selection[0], [ col_index, row_index ])) {\n\n                // update source exit side\n                this.source_exit_side = exit_side;\n            }\n\n            let target_coords;\n\n            // if exited top\n            if (exit_side === 'top') {\n\n                target_coords = [ this.bg_col_grid_hover_index, row_index - 1 ];\n\n                // if target is potential\n                if (this.isNodePotential([ col_index, row_index ], target_coords)) {\n                    this.selection.push(target_coords);\n                }\n            }\n\n            // if exited bottom\n            else if (exit_side === 'bottom') {\n\n                let target_row_index = row_index + 1;\n                target_coords = [ this.bg_col_grid_hover_index, target_row_index ];\n\n                // if not spanning more than one row && target is potential\n                if (Math.abs(this.selection[0][1] - target_row_index) <= 1 && this.isNodePotential([ col_index, row_index ], target_coords)) {\n\n                    this.selection.push(target_coords);\n                }\n            }\n        }\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // grid handlers\n    //-------------------------------------------------\n\n    /**\n     * onRootDeselect\n     */\n    onRootDeselect() {\n\n        // reset source_exit_side\n        this.source_exit_side = null;\n\n        // nothing to do if there are no selections\n        if (this.selection.length === 0) {\n            return true;\n        }\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if selections\n        if (this.selection.length > 0) {\n\n            this.setNodeClass(this.selection[0][1], this.selection[0][0], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // reset if there are not 2 selections\n        if (this.selection.length > 0) {\n            this.selection = [];\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onBgColGridMouseOver\n     */\n    onBgColGridMouseOver(index) {\n\n        // do nothing if unchanged\n        if (this.bg_col_grid_hover_index === index) {\n            return true;\n        }\n\n        this.bg_col_grid_hover_index = index;\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            let target_coords = this.source_exit_side === 'top' ? [index, this.selection[0][1] - 1] : [index, this.selection[0][1] + 1];\n\n            // if target is potential\n            if (this.isNodePotential(this.selection[0], target_coords)) {\n                this.selection.push(target_coords);\n            }\n        }\n\n        // if 2 selections and new col index is potential\n        else if (this.selection.length === 2 && this.isNodePotential(this.selection[0], [index, this.selection[1][1]])) {\n            this.selection[1][0] = index;\n        }\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onRootMouseLeave\n     */\n    onRootMouseLeave() {\n\n        //-------------------------\n        // styles\n        //-------------------------\n\n        // if 1 selection\n        if (this.selection.length === 1) {\n\n            this.setNodeClass(this.selection[0][1], this.selection[0][0], 'source', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'potential_target', false);\n        }\n\n        // if 2 selections\n        else if (this.selection.length === 2) {\n\n            this.setNodeClass(this.selection[0][1], this.selection[0][0], 'source', false);\n            this.setNodeClass(this.selection[1][1], this.selection[1][0], 'target', false);\n            this.setPotentialNodeClasses(this.selection[0][1], this.selection[0][0], 'potential_target', false);\n        }\n\n        //-------------------------\n        // line updates\n        //-------------------------\n\n        // if 2 selections\n        if (this.selection.length === 2) {\n\n            // remove Unconnected lines\n            this.removeUnconnectedLines(this.selection);\n        }\n\n        //-------------------------\n        // selection updates\n        //-------------------------\n\n        this.selection = [];\n\n        this.$s.$apply();\n    }\n\n    //-------------------------------------------------\n    // line handlers\n    //-------------------------------------------------\n\n    /**\n     * onLineRemoveComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineRemoveComplete(source_coords, target_coords, line_index) {\n\n        // update data\n        //this.state[source_coords[1]].columns[source_coords[0]].join.splice(line_index, 1);\n\n        // update nodes\n        let source = this.nodes[source_coords[1]].columns[source_coords[0]];\n\n        let _was_line_connected = source.lines[ line_index ].connected;\n\n        // delete line\n        source.lines.splice(line_index, 1);\n\n        // if source node has no more lines then setAsNotConnected\n        if (source.lines.length === 0) {\n\n            // if  node has no parent connections\n            if (!this.doesNodeHaveConnectedParents(source_coords[1], source_coords[0])) {\n                this.setAsNotConnectedNode([ source_coords[0], source_coords[1] ]);\n            }\n        }\n\n        // external callback\n        // ... if line was connected\n        // ... dotted temp line used for showing intended target is not connected, and it's removal should not trigger callback\n        if (!_.isUndefined(this.onNodeConnectionChangeCallback) && _was_line_connected) {\n\n            // don't need to set here because this happens after onNodeDeselection\n            // this.was_connection_change_called = true;\n\n            let _params = {\n                source_row_index: source_coords[1],\n                source_col_index: source_coords[0],\n                target_row_index: target_coords[1],\n                target_col_index: target_coords[0],\n                is_connected: false\n            };\n            this.onNodeConnectionChangeCallback(_params);\n        }\n\n        this.is_connection_change_busy = false;\n\n        this.$s.$apply();\n    }\n\n    /**\n     * onLineDrawComplete\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param line_index\n     */\n    onLineDrawComplete(source_coords, target_coords) {\n\n        let is_node_waiting_for_connection = false;\n\n        _.forEach(this.nodes_waiting_for_connection, (node, index) => {\n            if (_.isEqual(node, target_coords)) {\n                is_node_waiting_for_connection = true;\n                this.nodes_waiting_for_connection.splice(index, 1);\n                return false;\n            }\n        });\n\n        if (is_node_waiting_for_connection) {\n\n            // connect node\n            this.setAsConnectedNode(target_coords);\n\n            // check active\n            this.checkActive();\n        }\n\n        this.$s.$apply();\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // utils\n    //\n    ////////////////////////////////////////////////\n\n    //-----------------------------\n    // active check\n    //-----------------------------\n\n    /**\n     * checkActive\n     */\n    checkActive() {\n\n        if (this.nodes.length === 0) {\n            return false;\n        }\n\n        _.forEach(this.nodes[0].columns, (col, col_index) => {\n            if (col.lines.length > 0) {\n                this.activateNode(0, col_index);\n            }\n        });\n    }\n\n    /**\n     * activateNode\n     *\n     * @param row_index\n     * @param col_index\n     */\n    activateNode(row_index, col_index) {\n\n        let node = this.nodes[ row_index ].columns[ col_index ];\n        node.active = true;\n\n        if (node.lines.length > 0) {\n\n            _.forEach(node.lines, (line) => {\n\n                // activate line\n                line.active = true;\n\n                // activate target node\n                this.activateNode(line.to[1], line.to[0]);\n            });\n        }\n    }\n\n    /**\n     * deactivateNode\n     *\n     * @param row_index\n     * @param col_index\n     */\n    deactivateNode(row_index, col_index) {\n\n        let node = this.nodes[ row_index ].columns[ col_index ];\n        node.active = false;\n\n        if (node.lines.length > 0) {\n            _.forEach(node.lines, (line) => {\n\n                // deactivate line\n                line.active = false;\n\n                let does_parent_have_active_nodes = this.doesNodeHaveActiveParents(line.to[1], line.to[0]);\n\n                // deactivate target node if no active parents\n                if (!does_parent_have_active_nodes) {\n                    this.deactivateNode(line.to[1], line.to[0]);\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // node potential\n    //-----------------------------\n\n    /**\n     * doesNodeHaveActiveParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveActiveParents(row_index, col_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        let result = false;\n        let parent_row_index = row_index - 1;\n        let parents = this.nodes[parent_row_index].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n            _.forEach(parent.lines, (line) => {\n\n                // if parent coords are not equal to exclude coords\n                // ... and parent has a line to this node\n                // ... and parent is active\n                if (!_.isEqual([ parent_col_index, parent_row_index ], exclude_coords) && _.isEqual(line.to, [ col_index, row_index ]) && parent.active) {\n                    result = true;\n                }\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * doesNodeHaveConnectedParents\n     *\n     * @param col_index\n     * @param row_index\n     * @param exclude_coords\n     */\n    doesNodeHaveConnectedParents(row_index, col_index, exclude_coords) {\n\n        if (row_index === 0) {\n            return false;\n        }\n\n        if (_.isUndefined(exclude_coords)) {\n            exclude_coords = [];\n        }\n\n        let result = false;\n        let parent_row_index = row_index - 1;\n        let parents = this.nodes[ parent_row_index ].columns;\n\n        _.forEach(parents, (parent, parent_col_index) => {\n\n            // if parent coords are not equal to exclude coords and parent is potential (potential parent node is always connected)\n            if (!_.isEqual([ parent_col_index, parent_row_index ], exclude_coords) && this.isNodePotential([ col_index, row_index ], [ parent_col_index, parent_row_index ])) {\n\n                result = true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * isNodePotential\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    isNodePotential(source_coords, target_coords) {\n\n        // if not ready\n        if (_.isUndefined(this.nodes[ target_coords[1] ])) {\n            return false;\n        }\n        if (_.isUndefined(this.nodes[ target_coords[1] ].columns[ target_coords[0] ])) {\n            return false;\n        }\n\n        // refuse if control\n        if (this.nodes[ target_coords[1] ].columns[ target_coords[0] ].control) {\n            return false;\n        }\n\n        // refuse if same row\n        if (source_coords[1] === target_coords[1]) {\n            return false;\n        }\n\n        // refuse if spanning more than 1 rows\n        if (Math.abs(source_coords[1] - target_coords[1]) > 1) {\n            return false;\n        }\n\n        // target row index out of bounds check\n        if (target_coords[1] >= this.nodes.length) {\n            return false;\n        }\n\n        // target col index out of bounds check\n        if (target_coords[0] >= this.nodes[ target_coords[1] ].columns.length) {\n            return false;\n        }\n\n        // check if target is parent or child\n        let is_target_parent = target_coords[1] < source_coords[1];\n        let source = this.nodes[ source_coords[1] ].columns[ source_coords[0] ];\n        let target = this.nodes[ target_coords[1] ].columns[ target_coords[0] ];\n        let result;\n\n        // if target is parent, then check if target has connected lines to source\n        if (is_target_parent) {\n\n            result = false;\n\n            // check that last exit was not bottom\n            if (this.source_exit_side === 'bottom') {\n                return false;\n            }\n\n            // check if target has an connected line from it source\n            _.forEach(target.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, source_coords)) {\n                    result = true;\n                    return false;\n                }\n            });\n        }\n\n        // if target is child, then\n        else {\n\n            result = true;\n\n            // check that last exit was not top\n            if (this.source_exit_side === 'top') {\n                return false;\n            }\n\n            // check if source does not have an connected line to it\n            _.forEach(source.lines, (line) => {\n                if (line.connected && _.isEqual(line.to, target_coords)) {\n                    result = false;\n                    return false;\n                }\n            });\n        }\n\n        return result;\n    }\n\n    //-----------------------------\n    // node classes\n    //-----------------------------\n\n    /**\n     * setLineClass\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param key\n     * @param value\n     */\n    setLineClass(source_coords, target_coords, key, value) {\n\n        // loop child row columns\n        _.forEach(this.nodes[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            // if child node is potential then update class property\n            if (_.isEqual(line.to, target_coords)) {\n                line[ key ] = value;\n            }\n        });\n    }\n\n    /**\n     * setNodeClass\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setNodeClass(row_index, col_index, key, value) {\n\n        // TODO: why was I doing this?\n        // if (_.has(this.nodes[ row_index ].columns[ col_index ], key)) {\n        //     this.nodes[ row_index ].columns[ col_index ][ key ] = value;\n        // }\n\n        this.nodes[ row_index ].columns[ col_index ][ key ] = value;\n    }\n\n    /**\n     * setPotentialNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialNodeClasses(row_index, col_index, key, value) {\n\n        this.setPotentialChildNodeClasses(row_index, col_index, key, value);\n        this.setPotentialParentNodeClasses(row_index, col_index, key, value);\n    }\n\n    /**\n     * setPotentialChildNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialChildNodeClasses(row_index, col_index, key, value) {\n\n        // if child row is not out of bounds\n        if ((row_index + 1) < (this.nodes.length)) {\n\n            // loop child row columns\n            _.forEach(this.nodes[ row_index + 1 ].columns, (child_col, child_col_index) => {\n\n                // if child node is potential then update class property\n                if (this.isNodePotential([ col_index, row_index ], [ child_col_index, row_index + 1 ])) {\n                    child_col[ key ] = value;\n                }\n            });\n        }\n    }\n\n    /**\n     * setPotentialParentNodeClasses\n     *\n     * @param col_index\n     * @param row_index\n     * @param key\n     * @param value\n     */\n    setPotentialParentNodeClasses(row_index, col_index, key, value) {\n\n        if (row_index > 0) {\n\n            // loop parent node columns\n            _.forEach(this.nodes[ row_index - 1 ].columns, (parent_col, parent_col_index) => {\n\n                // if parent node is potential then update class property\n                if (this.isNodePotential([ col_index, row_index ], [ parent_col_index, row_index - 1 ])) {\n                    parent_col[key] = value;\n                }\n            });\n        }\n    }\n\n    //-----------------------------\n    // viewport\n    //-----------------------------\n\n    /**\n     * setViewport\n     *\n     * @param cols\n     * @param rows\n     */\n    setViewport(cols, rows) {\n\n        let total_item_width = this.config.node_width + this.config.col_spacing;\n        let total_item_height = this.config.node_height + this.config.row_spacing;\n\n        this.viewport_width = total_item_width * cols;\n        this.viewport_height = total_item_height * rows;\n\n        this.viewport_style = {\n            'background-color': \"#ccc\",\n            'min-width': this.viewport_width + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.wrapper_style = {\n            'max-width': (this.viewport_width + this.config.max_viewport_width_increase) + \"px\",\n            'min-width': this.viewport_width + \"px\",\n            'max-height': (this.viewport_height + (this.config.max_viewport_height_increase * rows)) + \"px\",\n            'min-height': this.viewport_height + \"px\"\n        };\n\n        this.viewport_viewbox = \" 0 0 \" + this.viewport_width + \" \" + this.viewport_height;\n    }\n\n    /**\n     * checkViewport\n     *\n     * @param col_index\n     * @param row_index\n     */\n    checkViewport(col_index, row_index) {\n\n        let should_update_viewport = false;\n\n        // row bounds check\n        if (row_index >= this.grid_row_count) {\n\n            // increase rowspan\n            this.grid_row_count++;\n            should_update_viewport = true;\n        }\n\n        // col bounds check\n        if (col_index >= this.grid_col_count) {\n\n            // increase colspan\n            this.grid_col_count++;\n            should_update_viewport = true;\n\n            // add bg grid col\n            this.addBgGridCol(this.grid_col_count - 1);\n        }\n\n        // set viewport\n        if (should_update_viewport) {\n            this.setViewport(this.grid_col_count, this.grid_row_count);\n        }\n    }\n\n    //-----------------------------\n    // coords\n    //-----------------------------\n\n    /**\n     * calculateColX\n     *\n     * @param index\n     */\n    calculateColX(index) {\n        if (index === 0) {\n            return 0;\n        }\n        let first_col_width = this.config.node_width + (this.config.col_spacing / 2);\n        let col_width = this.config.node_width + (this.config.col_spacing);\n        return first_col_width + ((index - 1) * col_width);\n    }\n\n    /**\n     * calculateColWidth\n     *\n     * @param index\n     */\n    calculateColWidth(index) {\n        let total_item_width = index === 0 ? this.config.node_width + (this.config.col_spacing / 2) : this.config.node_width + this.config.col_spacing;\n        return total_item_width;\n    }\n\n    /**\n     * calculateRowY\n     *\n     * @param index\n     */\n    calculateRowY(index) {\n        let row_height = this.config.node_height + this.config.row_spacing;\n        return index * row_height;\n    }\n\n    /**\n     * calculateRowHeight\n     *\n     * @param index\n     */\n    calculateRowHeight() {\n        return this.config.node_height + this.config.row_spacing;\n    }\n\n    //-----------------------------\n    // drawing\n    //-----------------------------\n\n    /**\n     * addLine\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param connected\n     */\n    addLine(source_coords, target_coords, connected) {\n\n        // check bounds\n        if (target_coords[1] >= this.nodes.length) {\n            return false;\n        }\n\n        // get coords\n        let source_lock_coords = NodeUtils.getNodeCoords(source_coords[1], source_coords[0], NODE_BOTTOM, this.config);\n        let target_lock_coords = NodeUtils.getNodeCoords(target_coords[1], target_coords[0], NODE_TOP, this.config);\n\n        // add line properties\n        this.nodes[ source_coords[1] ].columns[ source_coords[0] ].lines.push({\n            connected: !_.isUndefined(connected) ? connected : false,\n            from: source_coords,\n            to: target_coords,\n            x1: source_lock_coords[0],\n            y1: source_lock_coords[1],\n            x2: target_lock_coords[0],\n            y2: target_lock_coords[1]\n        });\n\n        if (connected) {\n            // update data\n            // this.state[source_coords[1]].columns[source_coords[0]].join.push(target_coords[0]);\n        }\n    }\n\n    /**\n     * updateLineTarget\n     *\n     * @param source_coords\n     * @param target_coords\n     */\n    updateLineTarget(source_coords, target_coords) {\n\n        // get target lock coords\n        let target_lock_coords = NodeUtils.getNodeCoords(target_coords[1], target_coords[0], NODE_TOP, this.config);\n\n        // find line\n        _.forEach(this.nodes[ source_coords[1] ].columns[ source_coords[0] ].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.to = target_coords;\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeLine\n     *\n     * @param source_coords\n     * @param target_coords\n     * @param set_as_busy\n     */\n    removeLine(source_coords, target_coords, set_as_busy) {\n\n        if (set_as_busy) {\n            this.is_connection_change_busy = true;\n        }\n\n        // get target lock coords\n        let target_lock_coords = NodeUtils.getNodeCoords(source_coords[1], source_coords[0], NODE_BOTTOM, this.config);\n\n        // find line\n        _.forEach(this.nodes[source_coords[1]].columns[source_coords[0]].lines, (line) => {\n\n            if (_.isEqual(line.from, source_coords) && _.isEqual(line.to, target_coords)) {\n\n                let node = this.nodes[ target_coords[1] ].columns[ target_coords[0] ];\n                let node_has_connected_parents = this.doesNodeHaveConnectedParents(target_coords[1], target_coords[0], source_coords);\n\n                // if node has no lines & has no parent connections\n                if (node.lines.length === 0 && !node_has_connected_parents) {\n                    // set as not connected\n                    this.setAsNotConnectedNode(target_coords);\n                }\n\n                // if node has no parent connections\n                let node_has_active_parents = this.doesNodeHaveActiveParents(target_coords[1], target_coords[0], source_coords);\n\n                if (!node_has_active_parents) {\n\n                    // deactivate node\n                    this.deactivateNode(target_coords[1], target_coords[0]);\n                }\n\n                // set line properties\n                line.x2 = target_lock_coords[0];\n                line.y2 = target_lock_coords[1];\n                line.previous_to = line.to; // TODO: this feels a bit hacky\n                line.to = [ source_coords[0], source_coords[1] ];\n                return false;\n            }\n        });\n    }\n\n    /**\n     * removeUnconnectedLines\n     *\n     * @param selection\n     */\n    removeUnconnectedLines(selection) {\n        _.forEach(this.nodes[ selection[0][1] ].columns[ selection[0][0] ].lines, (line) => {\n            if (!line.connected) {\n                this.removeLine(this.selection[0], this.selection[1]);\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedLines\n     *\n     * @param selection\n     */\n    setAsConnectedLines(selection) {\n\n        _.forEach(this.nodes[ selection[0][1] ].columns[ selection[0][0] ].lines, (line, line_index) => {\n            if (!line.connected) {\n\n                // setAsConnected line\n                line.connected = true;\n\n                // setAsConnected nodes\n                this.setAsConnectedNode(line.from);\n                this.setAsConnectedNode(line.to);\n\n                // external callback\n                if (!_.isUndefined(this.onNodeConnectionChangeCallback)) {\n\n                    // so that onNodeDeselection can decide whether to call as well\n                    this.was_connection_change_called = true;\n\n                    let _params = {\n                        source_row_index: line.from[1],\n                        source_col_index: line.from[0],\n                        target_row_index: line.to[1],\n                        target_col_index: line.to[0],\n                        is_connected: true\n                    };\n                    this.onNodeConnectionChangeCallback(_params);\n                }\n            }\n        });\n    }\n\n    /**\n     * setAsConnectedNode\n     *\n     * @param coords\n     */\n    setAsConnectedNode(coords) {\n        this.nodes[ coords[1] ].columns[ coords[0] ].connected = true;\n    }\n\n    /**\n     * setAsNotConnectedNode\n     *\n     * @param coords\n     */\n    setAsNotConnectedNode(coords) {\n        this.nodes[ coords[1] ].columns[ coords[0] ].connected = false;\n    }\n\n    /**\n     * addNode\n     *\n     * @param row_index\n     * @param col_index\n     * @param label\n     * @param lines\n     * @param data\n     * @returns {boolean}\n     */\n    addNode(row_index, col_index, label, lines, data) {\n\n        // create row if it doesn't exist\n        if (row_index === this.nodes.length) {\n            this.nodes.push({columns: []});\n        }\n\n        // if node already exists (control) then remove and re-add after node\n        let removed_node;\n\n        if (!_.isUndefined(this.nodes[ row_index ].columns[ col_index ])) {\n            removed_node = this.nodes[ row_index ].columns.splice(col_index, 1);\n        }\n\n        // get top left coords\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n\n        // lines\n        let node_lines = [];\n        let line_source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n        _.forEach(lines, (line_target_col_index) => {\n\n            let line_target_coords = [ line_target_col_index, row_index + 1 ];\n            let line_target_lock_coords = NodeUtils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n            node_lines.push({\n                connected: true,\n                from: [ col_index, row_index ],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set nodes as connected\n            this.nodes_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set node properties\n        let node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: label,\n            connected: node_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: node_lines,\n            selected: _.has(data, \"selected\") ? data.selected : false,\n            highlight: _.has(data, \"highlight\") ? data.highlight : false\n        };\n\n        // if this node is selected\n        if (node.selected) {\n\n            // ... and there is another node already selected\n            // ... then remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = node.row_index;\n            this.highlight_selected_node.col_index = node.col_index;\n        }\n\n        // add node\n        this.nodes[ row_index ].columns.push(node);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n        // replace removed node\n        if (!_.isUndefined(removed_node)) {\n            this.addControlNode(removed_node[0].row_index);\n        }\n\n        this.new_node = { row_index, col_index };\n\n        // highlight node\n        // ... if configured to do so\n        // ... and not initialising\n\n        if (_.includes(this.config.highlight_node_on, HIGHLIGHT_NODE_ON_ADD) && !this.is_initialising) {\n\n            // remove existing node highlight\n            if (_.has(this.highlight_selected_node, 'row_index')) {\n                this.nodes[ this.highlight_selected_node.row_index ].columns[ this.highlight_selected_node.col_index ].selected = false;\n            }\n\n            // set highlighted selected node\n            this.highlight_selected_node.row_index = row_index;\n            this.highlight_selected_node.col_index = col_index;\n\n            // highlight node\n            this.nodes[ row_index ].columns[ col_index ].selected = true;\n        }\n\n        // external callback\n        // ... if not initialising\n        if (!_.isUndefined(this.onNodeAddedCallback) && !this.is_initialising) {\n            this.onNodeAddedCallback({ row_index, col_index });\n        }\n    }\n\n    /**\n     * updateNode\n     *\n     * @param col_index\n     * @param row_index\n     * @param label\n     * @param lines\n     */\n    updateNode(row_index, col_index, label, lines = []) {\n\n        // update label\n        if (!_.isUndefined(label) && this.nodes[ row_index ].columns[ col_index ].label !== label) {\n            this.nodes[ row_index ].columns[ col_index ].label = label;\n        }\n\n        // update lines\n        if (!_.isUndefined(lines)) {\n\n            let line_source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n            _.forEach(lines, (line_target_col_index) => {\n\n                let line_target_coords = [ line_target_col_index, row_index + 1 ];\n                let line_target_lock_coords     = NodeUtils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n                // if already has this connection\n                if (_.includes(_.map(this.nodes[ row_index ].columns[ col_index ].lines, (line) => line.to[0]), line_target_col_index)) {\n                    return;\n                }\n\n                this.nodes[ row_index ].columns[ col_index ].lines.push({\n                    connected: true,\n                    from: [ col_index, row_index ],\n                    to: line_target_coords,\n                    x1: line_source_lock_coords[0],\n                    y1: line_source_lock_coords[1],\n                    x2: line_target_lock_coords[0],\n                    y2: line_target_lock_coords[1]\n                });\n\n                this.setNodeClass(row_index, col_index, 'connected', true);\n\n                // set nodes as connected\n                this.nodes_waiting_for_connection.push(line_target_coords);\n            });\n        }\n    }\n\n    /**\n     * removeNode\n     *\n     * @param row_index\n     * @param col_index\n     */\n    removeNode(row_index, col_index) {\n\n        // remove lines\n        let _set_as_busy = false;\n        _.forEach(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n            this.removeLine(line.from, line.to, _set_as_busy);\n        });\n\n        // remove node\n        this.nodes[ row_index ].columns.splice(col_index, 1);\n\n        // update data\n        // this.state[ row_index ].columns.splice(col_index, 1);\n\n        // update siblings\n        for (let i = col_index; i < (this.nodes[ row_index ].columns.length); i++) {\n            this.updateNodeAfterSiblingAddedOrRemoved(row_index, i);\n\n            // if not last column (control)\n            if (i < this.nodes[ row_index ].columns.length - 1) {\n                // TODO: why not update nodes???\n                // this.state[ row_index ].columns[i].data.ui_column_index = i;\n                // this.state[ row_index ].columns[i].data.ui_row_index = row_index;\n            }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            let parent_row_index = row_index - 1;\n            let remove_lines = [];\n\n            _.forEach(this.nodes[parent_row_index].columns, (column, parent_col_index) => {\n                _.forEach(column.lines, (line, line_index) => {\n\n                    // if parent connects to this node\n                    if (_.isEqual(line.to, [col_index, row_index])) {\n\n                        // column.lines.splice(line_index, 1);\n\n                        // mark lines for removal\n                        remove_lines.push({\n                            row_index: parent_row_index,\n                            col_index: parent_col_index,\n                            line_index: line_index\n                        });\n\n                        // update data\n                        //this.state[parent_row_index].columns[parent_col_index].join.splice(line_index, 1);\n\n                        // if parent no longer has any lines\n                        if (column.lines.length === 0) {\n                            this.setAsNotConnectedNode([ parent_col_index, parent_row_index ]);\n                        }\n                    }\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] > col_index) {\n\n                        // update lines target\n                        let new_line_to = [line.to[0] - 1, line.to[1]];\n\n                        // get target lock coords\n                        let target_lock_coords = NodeUtils.getNodeCoords(new_line_to[1], new_line_to[0], NODE_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n\n            // remove lines\n            _.map(remove_lines, (data) => {\n                this.nodes[data.row_index].columns[data.col_index].lines.splice(data.line_index, 1);\n            });\n        }\n\n        // update children\n        // TODO: can we use node???\n        if (row_index !== this.nodes.length - 1) {\n            let children_row_index = row_index + 1;\n            _.forEach(this.nodes[children_row_index].columns, (column, children_col_index) => {\n\n                // if  node has no parent connections\n                if (!this.doesNodeHaveConnectedParents(children_row_index, children_col_index)) {\n                    this.setAsNotConnectedNode([ children_col_index, children_row_index ]);\n                }\n            });\n        }\n    }\n\n    /**\n     * insertNode\n     *\n     * @param row_index\n     * @param col_index\n     * @param label\n     * @param joins\n     * @returns {boolean}\n     */\n    insertNode(row_index, col_index, label, joins) {\n\n        // get top left coords\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n\n        // lines\n        let node_lines = [];\n        let line_source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_BOTTOM, this.config);\n\n        _.forEach(joins, (line_target_col_index) => {\n\n            let line_target_coords = [line_target_col_index, row_index + 1];\n            let line_target_lock_coords = NodeUtils.getNodeCoords(line_target_coords[1], line_target_coords[0], NODE_TOP, this.config);\n\n            node_lines.push({\n                connected: true,\n                from: [col_index, row_index],\n                to: line_target_coords,\n                x1: line_source_lock_coords[0],\n                y1: line_source_lock_coords[1],\n                x2: line_target_lock_coords[0],\n                y2: line_target_lock_coords[1]\n            });\n\n            // set nodes as connected\n            this.nodes_waiting_for_connection.push(line_target_coords);\n        });\n\n        // set node properties\n        let node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: top_left_coords[0] + this.config.label_spacing,\n            label_y: top_left_coords[1] + this.config.label_spacing,\n            label: label,\n            connected: node_lines.length > 0,\n            control: false,\n            row_index: row_index,\n            col_index: col_index,\n            lines: node_lines\n        };\n\n        // TODO: add highlight and selected\n\n        // insert node\n        this.nodes[ row_index ].columns.splice(col_index, 0, node);\n\n        // update data\n        //this.state[ row_index ].columns.splice(col_index, 0, data);\n\n        // update siblings\n        for (let i = col_index + 1; i < (this.nodes[ row_index ].columns.length); i++) {\n\n            this.updateNodeAfterSiblingAddedOrRemoved(row_index, i);\n\n            // if not last column (control)\n            // if (i < this.nodes[ row_index ].columns.length - 1) {\n            //     this.state[ row_index ].columns[i].data.ui_column_index = i;\n            //     this.state[ row_index ].columns[i].data.ui_row_index = row_index;\n            // }\n        }\n\n        // update parents\n        if (row_index !== 0) {\n            let parent_row_index = row_index - 1;\n            _.forEach(this.nodes[parent_row_index].columns, (column) => {\n                _.forEach(column.lines, (line) => {\n\n                    // if parent connects to a sibling (right) then adjust line target col index\n                    if (line.to[0] >= col_index) {\n\n                        // update lines target\n                        let new_line_to = [line.to[0] + 1, line.to[1]];\n\n                        // get target lock coords\n                        let target_lock_coords = NodeUtils.getNodeCoords(new_line_to[1], new_line_to[0], NODE_TOP, this.config);\n\n                        line.to = [new_line_to[0], new_line_to[1]];\n                        line.x2 = target_lock_coords[0];\n                        line.y2 = target_lock_coords[1];\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * updateNodeAfterSiblingAddedOrRemoved\n     *\n     * @param {Integer}    row_index\n     * @param {Integer}    col_index\n     */\n    updateNodeAfterSiblingAddedOrRemoved(row_index, col_index) {\n\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        let center_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // update node\n\n        this.nodes[ row_index ].columns[ col_index ].col_index = col_index;\n        this.nodes[ row_index ].columns[ col_index ].coords = top_left_coords;\n        this.nodes[ row_index ].columns[ col_index ].x = top_left_coords[0];\n        this.nodes[ row_index ].columns[ col_index ].y = top_left_coords[1];\n\n        // update labels\n        // last node has different label position\n        if (col_index === (this.nodes[ row_index ].columns.length - 1)) {\n            this.nodes[ row_index ].columns[ col_index ].label_x = center_coords[0];\n            this.nodes[ row_index ].columns[ col_index ].label_y = center_coords[1];\n        } else {\n            this.nodes[ row_index ].columns[ col_index ].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.nodes[ row_index ].columns[ col_index ].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n\n            // get target lock coords\n            let source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n    }\n\n    /**\n     * updateNodeAfterChildAddedOrRemoved\n     *\n     * @param {Integer}    row_index\n     * @param {Integer}    col_index\n     */\n    updateNodeAfterChildAddedOrRemoved(row_index, col_index) {\n\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        let center_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // update node\n\n        this.nodes[ row_index ].columns[ col_index ].col_index = col_index;\n        this.nodes[ row_index ].columns[ col_index ].coords = top_left_coords;\n        this.nodes[ row_index ].columns[ col_index ].x = top_left_coords[0];\n        this.nodes[ row_index ].columns[ col_index ].y = top_left_coords[1];\n\n        // update labels\n        // last node has different label position\n        if (col_index === (this.nodes[ row_index ].columns.length - 1)) {\n            this.nodes[ row_index ].columns[ col_index ].label_x = center_coords[0];\n            this.nodes[ row_index ].columns[ col_index ].label_y = center_coords[1];\n        } else {\n            this.nodes[ row_index ].columns[ col_index ].label_x = top_left_coords[0] + this.config.label_spacing;\n            this.nodes[ row_index ].columns[ col_index ].label_y = top_left_coords[1] + this.config.label_spacing;\n        }\n\n        // update lines\n        _.forEach(this.nodes[ row_index ].columns[ col_index ].lines, (line) => {\n\n            // get target lock coords\n            let source_lock_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP, this.config);\n\n            line.from = [col_index, row_index];\n            line.x1 = source_lock_coords[0];\n            line.y1 = source_lock_coords[1];\n        });\n\n        // check viewport\n        this.checkViewport(row_index, col_index);\n    }\n\n    /**\n     * addControlNode\n     *\n     * @param {Integer}    row_index\n     */\n    addControlNode(row_index) {\n\n        // create row if it doesn't exist\n        if (row_index === this.nodes.length) {\n            this.nodes.push({columns: []});\n        }\n\n        // validate row index\n        if (row_index >= this.nodes.length) {\n            throw new Error(\"Invalid row index\");\n        }\n\n        let col_index = this.nodes[ row_index ].columns.length;\n\n        // get top left coords\n        let top_left_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_TOP_LEFT, this.config);\n        let center_coords = NodeUtils.getNodeCoords(row_index, col_index, NODE_CENTER, this.config);\n\n        // set node properties\n        let node = {\n            coords: top_left_coords,\n            x: top_left_coords[0],\n            y: top_left_coords[1],\n            label_x: center_coords[0],\n            label_y: center_coords[1],\n            label: \"+\",\n            connected: false,\n            control: true,\n            row_index: row_index,\n            col_index: col_index,\n            lines: []\n        };\n\n        // add node\n        this.nodes[ row_index ].columns.push(node);\n\n        // check viewport\n        this.checkViewport(col_index, row_index);\n\n    }\n\n    /**\n     * addBgGridCol\n     *\n     * @param {Integer}    index\n     */\n    addBgGridCol(index) {\n\n        this.bg_col_grid.push({\n            index: index,\n            x: this.calculateColX(index),\n            width: this.calculateColWidth(index)\n        });\n    }\n\n    ////////////////////////////////////////////////\n    //\n    // update\n    //\n    ////////////////////////////////////////////////\n\n    /**\n     * update\n     *\n     * @param data\n     * @param column_property_name\n     */\n    update(data, column_property_name) {\n\n        // add controls\n        _.forEach(data, (row, row_index) => {\n\n            // ... if row index exceeds or equals current UI rows\n            if (row_index >= this.nodes.length) {\n                this.addControlNode(row_index);\n            }\n        });\n\n        // add nodes\n        _.forEach(data, (row, row_index) => {\n            _.forEach(row[column_property_name], (col, col_index) => {\n\n                // update node\n                this.updateNode(row_index, col_index, col.label);\n\n                // ... if column index exceeds or equals current UI cols (excluding control)\n                if (col_index >= this.nodes[ row_index ].columns.length - 1) {\n                    let label = _.has(col, 'label') ? col.label : \"\";\n                    let lines = _.has(col, 'join') ? col.join : [];\n                    this.addNode(row_index, col_index, label, lines);\n                }\n            });\n        });\n\n        // set viewport\n        this.setViewport(this.grid_col_count, this.grid_row_count);\n\n        // check active\n        this.checkActive();\n    }\n}\n\nAngularSvgNodesController.$inject = [ '$scope' ];"],"sourceRoot":"src/app/*.js"}